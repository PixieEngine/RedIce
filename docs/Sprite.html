<!doctype html>
<html>
  <head>
    <meta charset='utf-8' />
    <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible' />
    <title>Sprite</title>
    <link href='/assets/spacedocs/docs.css' media='screen, projection' rel='stylesheet' type='text/css' />
    <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js' type='text/javascript'></script>
  </head>
  <body>
    <pre></pre>
    <nav>
      <a href='Animated.html'>Animated</a>
      <a href='Array.html'>Array</a>
      <a href='Bindable.html'>Bindable</a>
      <a href='Boolean.html'>Boolean</a>
      <a href='Bounded.html'>Bounded</a>
      <a href='Camera.html'>Camera</a>
      <a href='Collidable.html'>Collidable</a>
      <a href='Collision.html'>Collision</a>
      <a href='Color.html'>Color</a>
      <a href='Core.html'>Core</a>
      <a href='Date.html'>Date</a>
      <a href='Drawable.html'>Drawable</a>
      <a href='Durable.html'>Durable</a>
      <a href='Engine.html'>Engine</a>
      <a href='Engine.Gamepads.html'>Engine.Gamepads</a>
      <a href='Engine.Joysticks.html'>Engine.Joysticks</a>
      <a href='Fadeable.html'>Fadeable</a>
      <a href='Flickerable.html'>Flickerable</a>
      <a href='Framerate.html'>Framerate</a>
      <a href='Function.html'>Function</a>
      <a href='GameObject.html'>GameObject</a>
      <a href='GameState.html'>GameState</a>
      <a href='Local.html'>Local</a>
      <a href='Math.html'>Math</a>
      <a href='Matrix.html'>Matrix</a>
      <a href='Movable.html'>Movable</a>
      <a href='Music.html'>Music</a>
      <a href='Number.html'>Number</a>
      <a href='Object.html'>Object</a>
      <a href='PixieCanvas.html'>PixieCanvas</a>
      <a href='Point.html'>Point</a>
      <a href='PowerCanvas.html'>PowerCanvas</a>
      <a href='Random.html'>Random</a>
      <a href='RegExp.html'>RegExp</a>
      <a href='ResourceLoader.html'>ResourceLoader</a>
      <a href='Rotatable.html'>Rotatable</a>
      <a href='Sound.html'>Sound</a>
      <a class='active' href='Sprite.html'>Sprite</a>
      <a href='String.html'>String</a>
      <a href='jQuery.html'>jQuery</a>
      <a href='justPressed.html'>justPressed</a>
      <a href='keydown.html'>keydown</a>
      <a href='requestAnimationFrame.html'>requestAnimationFrame</a>
      <a href='window.html'>window</a>
    </nav>
    <section class='method_list'>
      <h3>Sprite Methods</h3>
      <div class='methods'>
        <a href='Sprite.html##draw'>#draw</a>
        <a href='Sprite.html##fill'>#fill</a>
        <a href='Sprite.html#.fromPixieId'>.fromPixieId</a>
        <a href='Sprite.html#.fromURL'>.fromURL</a>
        <a href='Sprite.html#.load'>.load</a>
        <a href='Sprite.html#.loadByName'>.loadByName</a>
        <a href='Sprite.html#.loadSheet'>.loadSheet</a>
      </div>
    </section>
    <div class='documentation'>
      <h1>Sprite Summary</h1>
      <div class='description'>
        <section class='summary'></section>
        <p>The Sprite class provides a way to load images for use in games.</p>
        <section class='usage'>
          <h3>Usage</h3>
          <p>By default, images are loaded asynchronously. A proxy object is <br />returned immediately. Even though it has a draw method it will not<br />draw anything to the screen until the image has been loaded.</p>
        </section>
      </div>
      <hr />
      <a name='#draw'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>Sprite#draw(canvas, x, y)</h1>
      <div class='description'>
        <section class='summary'><p>Draw this sprite on the given canvas at the given position.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>canvas</span>
               -
              <span class='param_description'>Reference to the canvas to draw the sprite on</span>
            </li>
            <li>
              <span class='param_name'>x</span>
               -
              <span class='param_description'>Position on the x axis to draw the sprite</span>
            </li>
            <li>
              <span class='param_name'>y</span>
               -
              <span class='param_description'>Position on the y axis to draw the sprite</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='.html'></a>
          </p>
          <p class='return_description'></p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>draw: function(canvas, x, y) {&#x000A;        return canvas.drawImage(image, sourceX, sourceY, width, height, x, y, width, height);&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#fill'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>Sprite#fill(canvas, x, y, width, height, repeat)</h1>
      <div class='description'>
        <section class='summary'><p>Draw this sprite on the given canvas tiled to the x, y, <br />width, and height dimensions specified.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>canvas</span>
               -
              <span class='param_description'>Reference to the canvas to draw the sprite on</span>
            </li>
            <li>
              <span class='param_name'>x</span>
               -
              <span class='param_description'>Position on the x axis to draw the sprite</span>
            </li>
            <li>
              <span class='param_name'>y</span>
               -
              <span class='param_description'>Position on the y axis to draw the sprite</span>
            </li>
            <li>
              <span class='param_name'>width</span>
               -
              <span class='param_description'>How far to tile the sprite on the x-axis</span>
            </li>
            <li>
              <span class='param_name'>height</span>
               -
              <span class='param_description'>How far to tile the sprite on the y-axis</span>
            </li>
            <li>
              <span class='param_name'>repeat</span>
               -
              <span class='param_description'>Repeat options. Can be `repeat-x`, `repeat-y`, `no-repeat`, or `repeat`. Defaults to `repeat`</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='.html'></a>
          </p>
          <p class='return_description'></p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>fill: function(canvas, x, y, width, height, repeat) {&#x000A;        var pattern;&#x000A;        if (repeat == null) repeat = "repeat";&#x000A;        pattern = canvas.createPattern(image, repeat);&#x000A;        return canvas.drawRect({&#x000A;          x: x,&#x000A;          y: y,&#x000A;          width: width,&#x000A;          height: height,&#x000A;          color: pattern&#x000A;        });&#x000A;      },&#x000A;      width: width,&#x000A;      height: height&#x000A;    };&#x000A;  };</code></pre>
        </section>
      </div>
      <hr />
      <a name='.fromPixieId'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>Sprite.fromPixieId(id, callback)</h1>
      <div class='description'>
        <section class='summary'><p>Loads a sprite with the given pixie id.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>id</span>
               -
              <span class='param_description'>Pixie Id of the sprite to load</span>
            </li>
            <li>
              <span class='param_name'>callback</span>
               -
              <span class='param_description'>Function to execute once the image is loaded. The sprite proxy data is passed to this as a parameter.</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='Sprite.html'>Sprite</a>
          </p>
          <p class='return_description'></p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>Sprite.fromPixieId = function(id, callback) {&#x000A;    return Sprite.load("http://pixieengine.com/s3/sprites/" + id + "/original.png", callback);&#x000A;  };</code></pre>
        </section>
      </div>
      <hr />
      <a name='.fromURL'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>Sprite.fromURL(url, callback)</h1>
      <div class='description'>
        <section class='summary'><p>Loads a sprite from a given url.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>url</span>
               -
              <span class='param_description'>The url where the image to load is located</span>
            </li>
            <li>
              <span class='param_name'>callback</span>
               -
              <span class='param_description'>Function to execute once the image is loaded. The sprite proxy data is passed to this as a parameter.</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='Sprite.html'>Sprite</a>
          </p>
          <p class='return_description'></p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>Sprite.fromURL = Sprite.load;</code></pre>
        </section>
      </div>
      <hr />
      <a name='.load'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>Sprite.load(url, loadedCallback)</h1>
      <div class='description'>
        <section class='summary'><p>Loads a sprite from a given url.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>url</span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>loadedCallback</span>
               -
              <span class='param_description'></span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='Sprite.html'>Sprite</a>
          </p>
          <p class='return_description'>A sprite object</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>Sprite.load = function(url, loadedCallback) {&#x000A;    var img, proxy, sprite;&#x000A;    if (sprite = spriteCache[url]) {&#x000A;      if (loadedCallback != null) loadedCallback.defer(sprite);&#x000A;      return sprite;&#x000A;    }&#x000A;    img = new Image();&#x000A;    proxy = LoaderProxy();&#x000A;    img.onload = function() {&#x000A;      spriteCache[url] = Object.extend(proxy, Sprite(this));&#x000A;      return typeof loadedCallback === "function" ? loadedCallback(proxy) : void 0;&#x000A;    };&#x000A;    img.src = url;&#x000A;    return proxy;&#x000A;  };</code></pre>
        </section>
      </div>
      <hr />
      <a name='.loadByName'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>Sprite.loadByName(name, callback)</h1>
      <div class='description'>
        <section class='summary'><p>Loads a sprite with the given name.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>name</span>
               -
              <span class='param_description'>The name of the image in your images directory</span>
            </li>
            <li>
              <span class='param_name'>callback</span>
               -
              <span class='param_description'>Function to execute once the image is loaded. The sprite proxy data is passed to this as a parameter.</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='Sprite.html'>Sprite</a>
          </p>
          <p class='return_description'></p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>Sprite.loadByName = function(name, callback) {&#x000A;    return Sprite.load(ResourceLoader.urlFor("images", name), callback);&#x000A;  };&#x000A;  return (typeof exports !== "undefined" && exports !== null ? exports : this)["Sprite"] = Sprite;&#x000A;})();&#x000A;&#x000A;&#x000A;(function() {&#x000A;  var assetList, loadedList;&#x000A;  assetList = [];&#x000A;  loadedList = [];&#x000A;  Sprite.load = (function(oldLoad) {&#x000A;    return function(url, callback) {&#x000A;      assetList.push(url);&#x000A;      return oldLoad(url, function(sprite) {&#x000A;        loadedList.push(url);&#x000A;        return typeof callback === "function" ? callback(sprite) : void 0;&#x000A;      });&#x000A;    };&#x000A;  })(Sprite.load);&#x000A;  Sprite.loadSheet = (function(oldLoad) {&#x000A;    return function(name, tileWidth, tileHeight, scale, callback) {&#x000A;      assetList.push(name);&#x000A;      return oldLoad(name, tileWidth, tileHeight, scale, function(sprites) {&#x000A;        loadedList.push(name);&#x000A;        return typeof callback === "function" ? callback(sprites) : void 0;&#x000A;      });&#x000A;    };&#x000A;  })(Sprite.loadSheet);&#x000A;  return window.LoaderState = function(I) {&#x000A;    var loadingComplete, self;&#x000A;    if (I == null) I = {};&#x000A;    self = GameState(I);&#x000A;    loadingComplete = function() {&#x000A;      return loadedList.length >= assetList.length;&#x000A;    };&#x000A;    self.bind("update", function() {&#x000A;      loadedList.sort();&#x000A;      assetList.sort();&#x000A;      if (loadingComplete()) return engine.setState(MainMenuState());&#x000A;    });&#x000A;    self.bind("overlay", function(canvas) {&#x000A;      canvas.font("bold 48px consolas, 'Courier New', 'andale mono', 'lucida console', monospace");&#x000A;      canvas.centerText({&#x000A;        text: "Loading",&#x000A;        y: App.height / 2,&#x000A;        color: "#FFF"&#x000A;      });&#x000A;      canvas.centerText({&#x000A;        text: "" + loadedList.length + " / " + assetList.length,&#x000A;        y: App.height / 2 + 50,&#x000A;        color: "#FFF"&#x000A;      });&#x000A;      canvas.font("bold 10px consolas, 'Courier New', 'andale mono', 'lucida console', monospace");&#x000A;      assetList.each(function(asset, i) {&#x000A;        return canvas.drawText({&#x000A;          x: 12,&#x000A;          y: (i + 1) * 14,&#x000A;          text: asset&#x000A;        });&#x000A;      });&#x000A;      return loadedList.each(function(asset, i) {&#x000A;        return canvas.drawText({&#x000A;          x: 12 + App.width / 2,&#x000A;          y: (i + 1) * 14,&#x000A;          text: asset&#x000A;        });&#x000A;      });&#x000A;    });&#x000A;    return self;&#x000A;  };&#x000A;})();&#x000A;&#x000A;var AI;&#x000A;&#x000A;AI = function(I, self) {&#x000A;  var arenaCenter, directionAI, roles;&#x000A;  arenaCenter = Point(WALL_LEFT + WALL_RIGHT, WALL_TOP + WALL_BOTTOM).scale(0.5);&#x000A;  roles = ["youth", "goalie", "youth"];&#x000A;  directionAI = {&#x000A;    goalie: function() {&#x000A;      var ownGoal, targetPosition;&#x000A;      ownGoal = engine.find("Goal").select(function(goal) {&#x000A;        return goal.team() === I.teamStyle;&#x000A;      }).first();&#x000A;      if (ownGoal) {&#x000A;        targetPosition = ownGoal.center();&#x000A;        targetPosition = targetPosition.add((arenaCenter.subtract(targetPosition)).norm(24));&#x000A;      } else {&#x000A;        targetPosition = self.center();&#x000A;      }&#x000A;      if (targetPosition.subtract(self.center()).length() < 1) {&#x000A;        return self.center();&#x000A;      } else {&#x000A;        return targetPosition;&#x000A;      }&#x000A;    },&#x000A;    youth: function() {&#x000A;      var opposingGoal, targetPosition, _ref;&#x000A;      if (I.hasPuck) {&#x000A;        opposingGoal = engine.find("Goal").select(function(goal) {&#x000A;          return goal.team() !== I.teamStyle;&#x000A;        }).first();&#x000A;        if (opposingGoal) targetPosition = opposingGoal.center();&#x000A;      } else {&#x000A;        targetPosition = (_ref = engine.find("Puck").first()) != null ? _ref.center() : void 0;&#x000A;      }&#x000A;      return targetPosition || self.center();&#x000A;    }&#x000A;  };&#x000A;  I.role = roles[I.slot];&#x000A;  return {&#x000A;    computeDirection: function() {&#x000A;      var deltaPosition, targetPosition;&#x000A;      I.AI_TARGET = targetPosition = directionAI[I.role]();&#x000A;      deltaPosition = targetPosition.subtract(self.center());&#x000A;      if (deltaPosition.length() > 1) {&#x000A;        return deltaPosition.norm();&#x000A;      } else {&#x000A;        return deltaPosition;&#x000A;      }&#x000A;    }&#x000A;  };&#x000A;};&#x000A;&#x000A;var Base;&#x000A;&#x000A;Base = function(I) {&#x000A;  var self;&#x000A;  I || (I = {});&#x000A;  $.reverseMerge(I, {&#x000A;    fortitude: 1,&#x000A;    friction: 0,&#x000A;    strength: 1,&#x000A;    mass: 1,&#x000A;    velocity: Point(0, 0)&#x000A;  });&#x000A;  self = GameObject(I).extend({&#x000A;    bloody: $.noop,&#x000A;    crush: $.noop,&#x000A;    puck: function() {&#x000A;      return I["class"] === "Puck";&#x000A;    },&#x000A;    wipeout: $.noop,&#x000A;    controlPuck: $.noop,&#x000A;    controlCircle: function() {&#x000A;      return {&#x000A;        x: 0,&#x000A;        y: 0,&#x000A;        radius: 0&#x000A;      };&#x000A;    },&#x000A;    collides: function() {&#x000A;      return !I.wipeout;&#x000A;    },&#x000A;    collidesWithWalls: function() {&#x000A;      return true;&#x000A;    },&#x000A;    collisionPower: function(normal) {&#x000A;      return (I.velocity.dot(normal) + I.fortitude) * I.strength;&#x000A;    },&#x000A;    center: function(newCenter) {&#x000A;      if (newCenter != null) {&#x000A;        I.x = newCenter.x - I.width / 2;&#x000A;        I.y = newCenter.y - I.height / 2;&#x000A;        I.center = newCenter;&#x000A;        return self;&#x000A;      } else {&#x000A;        return I.center;&#x000A;      }&#x000A;    },&#x000A;    updatePosition: function(dt, noFriction) {&#x000A;      var friction, frictionFactor;&#x000A;      if (noFriction) {&#x000A;        friction = 0;&#x000A;      } else {&#x000A;        friction = I.friction;&#x000A;      }&#x000A;      frictionFactor = 1 - friction * dt;&#x000A;      I.velocity.x *= frictionFactor;&#x000A;      I.velocity.y *= frictionFactor;&#x000A;      I.x += I.velocity.x * dt;&#x000A;      I.y += I.velocity.y * dt;&#x000A;      I.center.x = I.x + I.width / 2;&#x000A;      I.center.y = I.y + I.height / 2;&#x000A;      return self.trigger("positionUpdated");&#x000A;    }&#x000A;  });&#x000A;  if ((I.velocity != null) && (I.velocity.x != null) && (I.velocity.y != null)) {&#x000A;    I.velocity = Point(I.velocity.x, I.velocity.y);&#x000A;  }&#x000A;  self.bind("update", function() {&#x000A;    return I.zIndex = 1 + (I.y + I.height) / CANVAS_HEIGHT;&#x000A;  });&#x000A;  self.bind("drawDebug", function(canvas) {&#x000A;    var center;&#x000A;    if (I.radius) {&#x000A;      center = self.center();&#x000A;      return canvas.drawCircle({&#x000A;        position: center,&#x000A;        radius: I.radius,&#x000A;        color: "rgba(255, 0, 255, 0.5)"&#x000A;      });&#x000A;    }&#x000A;  });&#x000A;  self.attrReader("mass");&#x000A;  I.center = Point(I.x + I.width / 2, I.y + I.height / 2);&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var Blood;&#x000A;&#x000A;Blood = function(I) {&#x000A;  var self;&#x000A;  $.reverseMerge(I, {&#x000A;    blood: 1,&#x000A;    duration: 300,&#x000A;    radius: 2,&#x000A;    sprite: Sprite.NONE,&#x000A;    width: 32,&#x000A;    height: 32&#x000A;  });&#x000A;  self = GameObject(I).extend({&#x000A;    circle: function() {&#x000A;      var c;&#x000A;      c = self.center();&#x000A;      c.radius = I.radius;&#x000A;      return c;&#x000A;    }&#x000A;  });&#x000A;  Blood.sprites.rand().draw(bloodCanvas, I.x, I.y);&#x000A;  return self;&#x000A;};&#x000A;&#x000A;Blood.sprites || (Blood.sprites = [Sprite.loadByName("blood")]);&#x000A;&#x000A;var Boards;&#x000A;&#x000A;Boards = function(I) {&#x000A;  var self;&#x000A;  Object.reverseMerge(I, {&#x000A;    width: ARENA_WIDTH - 256,&#x000A;    height: 64,&#x000A;    x: WALL_LEFT + 128&#x000A;  });&#x000A;  self = GameObject(I).extend({&#x000A;    draw: function(canvas) {&#x000A;      return canvas.withTransform(Matrix.translation(I.x, I.y), function() {&#x000A;        return I.sprite.fill(canvas, 0, 0, I.width, I.height);&#x000A;      });&#x000A;    }&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var Bottle;&#x000A;&#x000A;Bottle = function(I) {&#x000A;  var addParticleEffect, drawSplat, fluidColor, particleSizes, self, splatSizes;&#x000A;  $.reverseMerge(I, {&#x000A;    color: "#A00",&#x000A;    radius: 8,&#x000A;    rotation: rand() * Math.TAU,&#x000A;    rotationalVelocity: (rand() * 2 - 1) * Math.TAU / 16,&#x000A;    spriteName: "freedomade",&#x000A;    velocity: Point(rand(5) - 2, 2 + rand(4) + rand(4)),&#x000A;    z: 48,&#x000A;    zVelocity: 4 + rand(6),&#x000A;    gravity: -0.25&#x000A;  });&#x000A;  I.width = I.height = I.radius;&#x000A;  fluidColor = Color(0, 255, 0, 0.5);&#x000A;  splatSizes = [2, 2, 2, 3, 4, 6];&#x000A;  drawSplat = function() {&#x000A;    return splatSizes.each(function(radius) {&#x000A;      var maxOffset;&#x000A;      maxOffset = 7 - radius;&#x000A;      maxOffset *= maxOffset;&#x000A;      return bloodCanvas.drawCircle({&#x000A;        x: I.x + I.width / 2 + (rand() - 0.5) * maxOffset,&#x000A;        y: I.y + I.height / 2 + (rand() - 0.5) * maxOffset,&#x000A;        radius: radius,&#x000A;        color: fluidColor&#x000A;      });&#x000A;    });&#x000A;  };&#x000A;  particleSizes = [4, 3, 5];&#x000A;  addParticleEffect = function() {&#x000A;    return engine.add({&#x000A;      "class": "Emitter",&#x000A;      duration: 10,&#x000A;      sprite: Sprite.EMPTY,&#x000A;      velocity: Point(0, 0),&#x000A;      particleCount: 12,&#x000A;      batchSize: 4,&#x000A;      x: I.x + I.width / 2,&#x000A;      y: I.y - I.z,&#x000A;      generator: {&#x000A;        color: fluidColor,&#x000A;        duration: 3,&#x000A;        height: function(n) {&#x000A;          return particleSizes.wrap(n);&#x000A;        },&#x000A;        maxSpeed: 5,&#x000A;        velocity: function(n) {&#x000A;          return Point.fromAngle(Random.angle()).scale(rand(5) + 1);&#x000A;        },&#x000A;        width: function(n) {&#x000A;          return particleSizes.wrap(n);&#x000A;        }&#x000A;      }&#x000A;    });&#x000A;  };&#x000A;  self = Base(I).extend({&#x000A;    draw: function(canvas) {&#x000A;      var bonusRadius, center, shadowColor, transform;&#x000A;      center = self.center();&#x000A;      shadowColor = "rgba(0, 0, 0, 0.15)";&#x000A;      bonusRadius = (-4 + 256 / I.z).clamp(-4, 4);&#x000A;      canvas.drawCircle({&#x000A;        position: center,&#x000A;        radius: I.radius + bonusRadius,&#x000A;        color: shadowColor&#x000A;      });&#x000A;      transform = Matrix.translation(I.x + I.width / 2, I.y + I.height / 2 - I.z).concat(Matrix.rotation(I.rotation)).concat(Matrix.translation(-I.width / 2, -I.height / 2));&#x000A;      return canvas.withTransform(transform, function() {&#x000A;        return I.sprite.draw(canvas, 0, 0);&#x000A;      });&#x000A;    }&#x000A;  });&#x000A;  self.bind("destroy", function() {&#x000A;    addParticleEffect();&#x000A;    drawSplat();&#x000A;    return Sound.play("bottle_hit");&#x000A;  });&#x000A;  self.bind("step", function() {&#x000A;    var players;&#x000A;    self.updatePosition(1);&#x000A;    I.rotation += I.rotationalVelocity;&#x000A;    I.z += I.zVelocity;&#x000A;    I.zVelocity += I.gravity;&#x000A;    if (I.z < 48) {&#x000A;      players = engine.find("Player");&#x000A;      players.each(function(player) {&#x000A;        if (Collision.circular(player.circle(), self.circle())) {&#x000A;          player.wipeout(player.center().subtract(self.center()));&#x000A;          return self.destroy();&#x000A;        }&#x000A;      });&#x000A;    }&#x000A;    if (I.z < 0) return self.destroy();&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var CharacterSheet;&#x000A;&#x000A;CharacterSheet = function(I) {&#x000A;  var BACK, FALL, FAST, FRONT, IDLE, SHOOT, SLOW, loadStrip, metadataUrl, self;&#x000A;  if (I == null) I = {};&#x000A;  Object.reverseMerge(I, {&#x000A;    character: "tubs",&#x000A;    team: "spike",&#x000A;    size: 512&#x000A;  });&#x000A;  loadStrip = function(action, facing, cells) {&#x000A;    return Sprite.loadSheet("" + I.team + "_" + I.character + "_" + action + "_" + facing + "_" + cells, I.size, I.size, 0.5);&#x000A;  };&#x000A;  FRONT = "se";&#x000A;  BACK = "ne";&#x000A;  FAST = "fast";&#x000A;  SLOW = "slow";&#x000A;  IDLE = "idle";&#x000A;  FALL = "falldown";&#x000A;  SHOOT = "shoot";&#x000A;  self = {&#x000A;    data: {},&#x000A;    fast: {&#x000A;      front: loadStrip(FAST, FRONT, 6),&#x000A;      back: loadStrip(FAST, BACK, 6)&#x000A;    },&#x000A;    slow: {&#x000A;      front: loadStrip(SLOW, FRONT, 6),&#x000A;      back: loadStrip(SLOW, BACK, 6)&#x000A;    },&#x000A;    idle: {&#x000A;      front: loadStrip(IDLE, FRONT, 2),&#x000A;      back: loadStrip(IDLE, BACK, 2)&#x000A;    },&#x000A;    fall: {&#x000A;      front: loadStrip(FALL, FRONT, 6)&#x000A;    },&#x000A;    shoot: {&#x000A;      front: loadStrip(SHOOT, FRONT, 11)&#x000A;    }&#x000A;  };&#x000A;  self.characterData = {&#x000A;    shootHoldFrame: 5,&#x000A;    shootCooldownFrameCount: 5&#x000A;  };&#x000A;  if (I.character === "skinny") {&#x000A;    self.characterData.shootHoldFrame = 3;&#x000A;    self.characterData.shootCooldownFrameCount = 6;&#x000A;  }&#x000A;  if (I.character === "thick") {&#x000A;    self.characterData.shootHoldFrame = 5;&#x000A;    self.characterData.shootCooldownFrameCount = 6;&#x000A;  }&#x000A;  metadataUrl = ResourceLoader.urlFor("data", "" + I.team + "_" + I.character);&#x000A;  $.getJSON(metadataUrl, function(data) {&#x000A;    return Object.extend(self.data, data);&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var Configurator;&#x000A;&#x000A;Configurator = function(I) {&#x000A;  var addNameEntry, finalizeConfig, horizontalPadding, join, lineHeight, self, teamStyles, unbindTapEvents, verticalPadding;&#x000A;  Object.reverseMerge(I, {&#x000A;    activePlayers: 0,&#x000A;    font: "bold 32px 'Monaco', 'Inconsolata', 'consolas', 'Courier New', 'andale mono', 'lucida console', 'monospace'",&#x000A;    maxPlayers: 6,&#x000A;    teamColors: {&#x000A;      "0": Color("#0246E3"),&#x000A;      "1": Color("#EB070E")&#x000A;    },&#x000A;    width: App.width,&#x000A;    height: App.height,&#x000A;    x: 0,&#x000A;    y: 0&#x000A;  });&#x000A;  lineHeight = 11;&#x000A;  verticalPadding = 24;&#x000A;  horizontalPadding = 0;&#x000A;  teamStyles = ["mutant", "hiss"];&#x000A;  join = function(id) {&#x000A;    var player;&#x000A;    player = I.config.players[id];&#x000A;    if (!player.cpu) return;&#x000A;    player.cpu = false;&#x000A;    player.ready = false;&#x000A;    I.activePlayers += 1;&#x000A;    return addNameEntry(player);&#x000A;  };&#x000A;  addNameEntry = function(player) {&#x000A;    var backgroundColor, cursorColor, id, nameEntry;&#x000A;    id = player.id;&#x000A;    backgroundColor = Color(player.color);&#x000A;    backgroundColor.a = 0.5;&#x000A;    cursorColor = backgroundColor.lighten(0.25);&#x000A;    nameEntry = engine.add({&#x000A;      backgroundColor: backgroundColor,&#x000A;      "class": "NameEntry",&#x000A;      controller: id,&#x000A;      cursorColor: cursorColor,&#x000A;      name: player.name,&#x000A;      x: id * (App.width / I.maxPlayers) + 4,&#x000A;      y: 40&#x000A;    });&#x000A;    nameEntry.bind("change", function(name) {&#x000A;      return player.name = name;&#x000A;    });&#x000A;    return nameEntry.bind("done", function(name) {&#x000A;      nameEntry.destroy();&#x000A;      player.name = name;&#x000A;      player.optionIndex = 0;&#x000A;      return player.tapListener = function(p) {&#x000A;        var currentOption;&#x000A;        if (player.ready) return;&#x000A;        if (p.y) {&#x000A;          return player.optionIndex = (player.optionIndex + p.y).clamp(0, Configurator.options.length - 1);&#x000A;        } else {&#x000A;          if ((currentOption = Configurator.options[player.optionIndex])) {&#x000A;            if (currentOption.action) {} else {&#x000A;              return player[currentOption.name] += p.x;&#x000A;            }&#x000A;          }&#x000A;        }&#x000A;      };&#x000A;    });&#x000A;  };&#x000A;  unbindTapEvents = function() {&#x000A;    return I.config.players.each(function(player) {&#x000A;      return player.tapListener = null;&#x000A;    });&#x000A;  };&#x000A;  finalizeConfig = function(config) {&#x000A;    var blues, cpu, cpus, humans, reds, _ref, _ref2, _ref3;&#x000A;    _ref = config.players.partition(function(playerData) {&#x000A;      return playerData.cpu;&#x000A;    }), cpus = _ref[0], humans = _ref[1];&#x000A;    _ref2 = humans.partition(function(playerData) {&#x000A;      return playerData.team = playerData.teamIndex.mod(teamStyles.length);&#x000A;    }), reds = _ref2[0], blues = _ref2[1];&#x000A;    while ((blues.length < I.maxPlayers / 2) && cpus.length) {&#x000A;      cpu = cpus.pop();&#x000A;      cpu.team = 0;&#x000A;      blues.push(cpu);&#x000A;    }&#x000A;    while ((reds.length < I.maxPlayers / 2) && cpus.length) {&#x000A;      cpu = cpus.pop();&#x000A;      cpu.team = 1;&#x000A;      reds.push(cpu);&#x000A;    }&#x000A;    _ref3 = config.players.partition(function(playerData) {&#x000A;      return playerData.team;&#x000A;    }), reds = _ref3[0], blues = _ref3[1];&#x000A;    reds.each(function(red, i) {&#x000A;      red.slot = i;&#x000A;      red.y = WALL_TOP + ARENA_HEIGHT * (i + 1) / (reds.length + 1);&#x000A;      red.x = WALL_LEFT + ARENA_WIDTH / 2 + ARENA_WIDTH / 6;&#x000A;      red.heading = 0.5.rotations;&#x000A;      return red.teamStyle = teamStyles[0];&#x000A;    });&#x000A;    blues.each(function(blue, i) {&#x000A;      blue.slot = i;&#x000A;      blue.y = WALL_TOP + ARENA_HEIGHT * (i + 1) / (blues.length + 1);&#x000A;      blue.x = WALL_LEFT + ARENA_WIDTH / 2 - ARENA_WIDTH / 6;&#x000A;      return blue.teamStyle = teamStyles[1];&#x000A;    });&#x000A;    return config;&#x000A;  };&#x000A;  self = GameObject(I).extend({&#x000A;    draw: function(canvas) {&#x000A;      canvas.font(I.font);&#x000A;      self.trigger("beforeTransform", canvas);&#x000A;      return canvas.withTransform(Matrix.translation(I.x, I.y), function() {&#x000A;        return I.config.players.each(function(player, i) {&#x000A;          var color, name, nameWidth, x, y;&#x000A;          y = 0;&#x000A;          x = player.id * App.width / MAX_PLAYERS;&#x000A;          if (player.cpu) {&#x000A;            name = "CPU";&#x000A;            color = Color(Player.CPU_COLOR);&#x000A;          } else {&#x000A;            name = player.name || ("P" + (player.id + 1));&#x000A;          }&#x000A;          nameWidth = canvas.measureText(name);&#x000A;          player.headStyle = TeamSheet.headStyles.wrap(player.headIndex) || "stubs";&#x000A;          player.bodyStyle = TeamSheet.bodyStyles.wrap(player.bodyIndex) || "thick";&#x000A;          player.teamStyle = teamStyles.wrap(player.teamIndex + 1) || 0;&#x000A;          Configurator.images[player.teamStyle].background.draw(canvas, x, 0);&#x000A;          if ((player.optionIndex != null) && !player.ready) {&#x000A;            Configurator.active.draw(canvas, x, Configurator.options[player.optionIndex].y);&#x000A;          }&#x000A;          Configurator.border.draw(canvas, x, 0);&#x000A;          Configurator.images[player.teamStyle].nameBubble.draw(canvas, x, 0);&#x000A;          Configurator.images[player.teamStyle].logo.draw(canvas, x - 42, 375);&#x000A;          if (player.ready) {&#x000A;            Configurator.images[player.teamStyle].readyBubbleActive.draw(canvas, x, I.height - 62);&#x000A;          } else {&#x000A;            Configurator.images[player.teamStyle].readyBubble.draw(canvas, x, I.height - 62);&#x000A;          }&#x000A;          canvas.centerText({&#x000A;            text: name,&#x000A;            x: x + I.width / 12 + 2,&#x000A;            y: y + lineHeight + verticalPadding + 1,&#x000A;            color: "black"&#x000A;          });&#x000A;          canvas.centerText({&#x000A;            text: name,&#x000A;            x: x + I.width / 12,&#x000A;            y: y + lineHeight + verticalPadding,&#x000A;            color: "white"&#x000A;          });&#x000A;          y = I.height / 2 - 50;&#x000A;          x += I.width / 12;&#x000A;          return canvas.withTransform(Matrix.translation(x, y), function(canvas) {&#x000A;            var bodySprite, headSprite;&#x000A;            if (bodySprite = teamSprites[player.teamStyle][player.bodyStyle].slow.front[0]) {&#x000A;              bodySprite.draw(canvas, -bodySprite.width / 2 - 10, -bodySprite.height / 2);&#x000A;            }&#x000A;            if (headSprite = teamSprites[player.teamStyle][player.headStyle].normal[0]) {&#x000A;              return headSprite != null ? headSprite.draw(canvas, -headSprite.width / 2 + 10, -headSprite.height / 2 - 40) : void 0;&#x000A;            }&#x000A;          });&#x000A;        });&#x000A;      });&#x000A;    }&#x000A;  });&#x000A;  self.bind("step", function() {&#x000A;    var readyPlayers;&#x000A;    I.maxPlayers.times(function(i) {&#x000A;      var controller, currentOption, player;&#x000A;      controller = engine.controller(i);&#x000A;      if (controller.actionDown("ANY")) join(i);&#x000A;      if ((player = I.config.players[i])) {&#x000A;        if (typeof player.tapListener === "function") {&#x000A;          player.tapListener(controller.tap());&#x000A;        }&#x000A;        if ((currentOption = Configurator.options[player.optionIndex])) {&#x000A;          if (currentOption.action === "toggle") {&#x000A;            if (controller.actionDown("A")) player[currentOption.name] = true;&#x000A;            if (controller.actionDown("B")) {&#x000A;              return player[currentOption.name] = false;&#x000A;            }&#x000A;          }&#x000A;        }&#x000A;      }&#x000A;    });&#x000A;    readyPlayers = I.config.players.select(function(player) {&#x000A;      return player.ready;&#x000A;    });&#x000A;    if (readyPlayers.length === I.activePlayers && readyPlayers.length > 0) {&#x000A;      unbindTapEvents();&#x000A;      return self.trigger("done", finalizeConfig(I.config));&#x000A;    }&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;Configurator.images = {};&#x000A;&#x000A;[["blue", "smiley"], ["red", "spike"], ["purple", "mutant"], ["green", "hiss"]].map(function(_arg) {&#x000A;  var style, team;&#x000A;  team = _arg[0], style = _arg[1];&#x000A;  return Configurator.images[style] = {&#x000A;    background: Sprite.loadByName("gameselect_back_" + team),&#x000A;    nameBubble: Sprite.loadByName("gameselect_namebubble_" + team),&#x000A;    readyBubble: Sprite.loadByName("gameselect_readybubble_" + team),&#x000A;    readyBubbleActive: Sprite.loadByName("gameselect_readybubble2_" + team),&#x000A;    logo: Sprite.loadByName("gameselect_" + style + "logo")&#x000A;  };&#x000A;});&#x000A;&#x000A;Configurator.ready = [];&#x000A;&#x000A;Configurator.active = Sprite.loadByName("gameselect_selectglow");&#x000A;&#x000A;Configurator.border = Sprite.loadByName("gameselect_borders");&#x000A;&#x000A;Configurator.options = [&#x000A;  {&#x000A;    name: "headIndex",&#x000A;    y: 200&#x000A;  }, {&#x000A;    name: "bodyIndex",&#x000A;    y: 250&#x000A;  }, {&#x000A;    name: "teamIndex",&#x000A;    y: 400&#x000A;  }, {&#x000A;    name: "ready",&#x000A;    action: "toggle",&#x000A;    y: 650&#x000A;  }&#x000A;];&#x000A;&#x000A;var CONTROLLERS, Controller, gameControlData, keyActionNames, layouts, selectedLayout,&#x000A;  __slice = Array.prototype.slice;&#x000A;&#x000A;Controller = function(actions) {&#x000A;  actions || (actions = {&#x000A;    up: "up"&#x000A;  });&#x000A;  return {&#x000A;    right: "right",&#x000A;    down: "down",&#x000A;    left: "left",&#x000A;    A: "home",&#x000A;    B: "end",&#x000A;    C: "pageup",&#x000A;    D: "pagedown",&#x000A;    actionDown: function() {&#x000A;      var triggers;&#x000A;      triggers = 1 <= arguments.length ? __slice.call(arguments, 0) : [];&#x000A;      return triggers.inject(false, function(down, action) {&#x000A;        return down || keydown[actions[action]];&#x000A;      });&#x000A;    }&#x000A;  };&#x000A;};&#x000A;&#x000A;gameControlData = {};&#x000A;&#x000A;keyActionNames = {&#x000A;  A: "SHOOT",&#x000A;  B: "BOOST",&#x000A;  C: "?",&#x000A;  D: "??"&#x000A;};&#x000A;&#x000A;CONTROLLERS = [];&#x000A;&#x000A;selectedLayout = Local.get("controls") || "qwerty_keyboard";&#x000A;&#x000A;layouts = {&#x000A;  dvorak_wiimotes: [&#x000A;    {&#x000A;      up: "up",&#x000A;      right: "right",&#x000A;      down: "down",&#x000A;      left: "left",&#x000A;      A: "end",&#x000A;      B: "home",&#x000A;      C: "pagedown",&#x000A;      D: "pageup"&#x000A;    }, {&#x000A;      up: "o",&#x000A;      right: "q",&#x000A;      down: ";",&#x000A;      left: "a",&#x000A;      A: "2",&#x000A;      B: "1",&#x000A;      C: ",",&#x000A;      D: "'"&#x000A;    }, {&#x000A;      up: "u",&#x000A;      right: "k",&#x000A;      down: "j",&#x000A;      left: "e",&#x000A;      A: "4",&#x000A;      B: "3",&#x000A;      C: "p",&#x000A;      D: "."&#x000A;    }, {&#x000A;      up: "d",&#x000A;      right: "b",&#x000A;      down: "x",&#x000A;      left: "i",&#x000A;      A: "6",&#x000A;      B: "5",&#x000A;      C: "f",&#x000A;      D: "y"&#x000A;    }, {&#x000A;      up: "t",&#x000A;      right: "w",&#x000A;      down: "m",&#x000A;      left: "h",&#x000A;      A: "8",&#x000A;      B: "7",&#x000A;      C: "c",&#x000A;      D: "g"&#x000A;    }, {&#x000A;      up: "s",&#x000A;      right: "z",&#x000A;      down: "v",&#x000A;      left: "n",&#x000A;      A: "0",&#x000A;      B: "9",&#x000A;      C: "l",&#x000A;      D: "r"&#x000A;    }, {&#x000A;      up: "=",&#x000A;      right: "return",&#x000A;      down: "-",&#x000A;      left: "/",&#x000A;      A: "]",&#x000A;      B: "[",&#x000A;      C: "\\",&#x000A;      D: "backspace"&#x000A;    }&#x000A;  ],&#x000A;  qwerty_keyboard: [&#x000A;    {&#x000A;      up: "up",&#x000A;      right: "right",&#x000A;      down: "down",&#x000A;      left: "left",&#x000A;      A: "'",&#x000A;      B: ";"&#x000A;    }, {&#x000A;      up: "w",&#x000A;      right: "d",&#x000A;      down: "s",&#x000A;      left: "a",&#x000A;      A: "b",&#x000A;      B: "space"&#x000A;    }, {}, {}, {}, {}, {}&#x000A;  ]&#x000A;};&#x000A;&#x000A;layouts[selectedLayout].each(function(actions, i) {&#x000A;  var action, key;&#x000A;  for (action in actions) {&#x000A;    key = actions[action];&#x000A;    gameControlData["P" + (i + 1) + ": " + (keyActionNames[action] || action)] = key;&#x000A;  }&#x000A;  return CONTROLLERS[i] = Controller(actions);&#x000A;});&#x000A;&#x000A;parent.gameControlData = gameControlData;&#x000A;&#x000A;var __slice = Array.prototype.slice;&#x000A;&#x000A;Function.prototype.delay = function() {&#x000A;  var args, func, wait;&#x000A;  wait = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];&#x000A;  func = this;&#x000A;  return setTimeout(function() {&#x000A;    return func.apply(null, args);&#x000A;  }, wait);&#x000A;};&#x000A;&#x000A;Function.prototype.defer = function() {&#x000A;  var args;&#x000A;  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];&#x000A;  return this.delay.apply(this, [1].concat(args));&#x000A;};&#x000A;&#x000A;&#x000A;(function() {&#x000A;  var Engine, defaults, oldEngine;&#x000A;  defaults = {&#x000A;    FPS: 30,&#x000A;    age: 0,&#x000A;    excludedModules: [],&#x000A;    includedModules: [],&#x000A;    paused: false,&#x000A;    showFPS: false,&#x000A;    zSort: false&#x000A;  };</code></pre>
        </section>
      </div>
      <hr />
      <a name='.loadSheet'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>Sprite.loadSheet(name, tileWidth, tileHeight)</h1>
      <div class='description'>
        <section class='summary'><p>Loads all sprites from a sprite sheet found in<br />your images directory, specified by the name passed in.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>name</span>
               -
              <span class='param_description'>Name of the spriteSheet image in your images directory</span>
            </li>
            <li>
              <span class='param_name'>tileWidth</span>
               -
              <span class='param_description'>Width of each sprite in the sheet</span>
            </li>
            <li>
              <span class='param_name'>tileHeight</span>
               -
              <span class='param_description'>Height of each sprite in the sheet</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='Array.html'>Array</a>
          </p>
          <p class='return_description'>An array of sprite objects</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>Sprite.loadSheet = function(name, tileWidth, tileHeight, scale, callback) {&#x000A;    var image, sprites, url;&#x000A;    if (scale == null) scale = 1;&#x000A;    url = ResourceLoader.urlFor("images", name);&#x000A;    sprites = [];&#x000A;    image = new Image();&#x000A;    image.onload = function() {&#x000A;      var context, height, imgElement, width;&#x000A;      imgElement = this;&#x000A;      width = this.width * scale;&#x000A;      height = this.height * scale;&#x000A;      tileWidth *= scale;&#x000A;      tileHeight *= scale;&#x000A;      if (scale !== 1) {&#x000A;        imgElement = $("<canvas width=" + width + " height=" + height + ">").get(0);&#x000A;        context = imgElement.getContext('2d');&#x000A;        context.drawImage(this, 0, 0, this.width, this.height, 0, 0, width, height);&#x000A;      }&#x000A;      (height / tileHeight).times(function(row) {&#x000A;        return (width / tileWidth).times(function(col) {&#x000A;          return sprites.push(Sprite(imgElement, col * tileWidth, row * tileHeight, tileWidth, tileHeight));&#x000A;        });&#x000A;      });&#x000A;      return typeof callback === "function" ? callback(sprites) : void 0;&#x000A;    };&#x000A;    image.src = url;&#x000A;    return sprites;&#x000A;  };</code></pre>
        </section>
      </div>
      <hr />
    </div>
  </body>
</html>
<script type='text/javascript'>
  //<![CDATA[
    $(function() {
      $(".documentation").on("click", ".toggle_source", function(e) {
        e.preventDefault();
        return $(this).next().toggle();
      });
      return $("code.run").each(function() {
        var canvas, codeElement, compiledJs, source;
        codeElement = $(this);
        source = codeElement.text();
        compiledJs = CoffeeScript.compile(source, {
          bare: true
        });
        canvas = $("<canvas width=200 height=150/>").pixieCanvas();
        codeElement.after(canvas);
        return eval(compiledJs);
      });
    });
  //]]>
</script>
