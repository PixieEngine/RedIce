<!doctype html>
<html>
  <head>
    <meta charset='utf-8' />
    <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible' />
    <title>Engine.Gamepads</title>
    <link href='/assets/spacedocs/docs.css' media='screen, projection' rel='stylesheet' type='text/css' />
    <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js' type='text/javascript'></script>
  </head>
  <body>
    <pre></pre>
    <nav>
      <a href='Animated.html'>Animated</a>
      <a href='Array.html'>Array</a>
      <a href='Bindable.html'>Bindable</a>
      <a href='Boolean.html'>Boolean</a>
      <a href='Bounded.html'>Bounded</a>
      <a href='Camera.html'>Camera</a>
      <a href='Collidable.html'>Collidable</a>
      <a href='Collision.html'>Collision</a>
      <a href='Color.html'>Color</a>
      <a href='Core.html'>Core</a>
      <a href='Date.html'>Date</a>
      <a href='Drawable.html'>Drawable</a>
      <a href='Durable.html'>Durable</a>
      <a href='Engine.html'>Engine</a>
      <a class='active' href='Engine.Gamepads.html'>Engine.Gamepads</a>
      <a href='Engine.Joysticks.html'>Engine.Joysticks</a>
      <a href='Fadeable.html'>Fadeable</a>
      <a href='Flickerable.html'>Flickerable</a>
      <a href='Framerate.html'>Framerate</a>
      <a href='Function.html'>Function</a>
      <a href='GameObject.html'>GameObject</a>
      <a href='GameState.html'>GameState</a>
      <a href='Local.html'>Local</a>
      <a href='Math.html'>Math</a>
      <a href='Matrix.html'>Matrix</a>
      <a href='Movable.html'>Movable</a>
      <a href='Music.html'>Music</a>
      <a href='Number.html'>Number</a>
      <a href='Object.html'>Object</a>
      <a href='PixieCanvas.html'>PixieCanvas</a>
      <a href='Point.html'>Point</a>
      <a href='PowerCanvas.html'>PowerCanvas</a>
      <a href='Random.html'>Random</a>
      <a href='RegExp.html'>RegExp</a>
      <a href='ResourceLoader.html'>ResourceLoader</a>
      <a href='Rotatable.html'>Rotatable</a>
      <a href='Sound.html'>Sound</a>
      <a href='Sprite.html'>Sprite</a>
      <a href='String.html'>String</a>
      <a href='jQuery.html'>jQuery</a>
      <a href='justPressed.html'>justPressed</a>
      <a href='keydown.html'>keydown</a>
      <a href='requestAnimationFrame.html'>requestAnimationFrame</a>
      <a href='window.html'>window</a>
    </nav>
    <section class='method_list'>
      <h3>Engine.Gamepads Methods</h3>
      <div class='methods'>
        <a href='Engine.Gamepads.html##controller'>#controller</a>
      </div>
    </section>
    <div class='documentation'>
      <a name='#controller'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>Engine.Gamepads#controller(index)</h1>
      <div class='description'>
        <section class='summary'><p>Get a controller for a given id.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>index</span>
               -
              <span class='param_description'>The index to get a controller for.</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='.html'></a>
          </p>
          <p class='return_description'></p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>controller: function(index) {&#x000A;      return gamepads.controller(index);&#x000A;    }&#x000A;  };&#x000A;};&#x000A;&#x000A;&#x000A;Engine.Stats = function(I, self) {&#x000A;  var stats;&#x000A;  if (I == null) I = {};&#x000A;  stats = xStats();&#x000A;  $(stats.element).css({&#x000A;    position: "absolute",&#x000A;    right: 0,&#x000A;    bottom: 0&#x000A;  }).appendTo("body");&#x000A;  return {};&#x000A;};&#x000A;&#x000A;var Fan;&#x000A;&#x000A;Fan = function(I) {&#x000A;  var self;&#x000A;  Object.reverseMerge(I, {&#x000A;    sprite: Fan.sprites.rand(),&#x000A;    width: 32,&#x000A;    height: 32,&#x000A;    y: 128,&#x000A;    zIndex: -10&#x000A;  });&#x000A;  self = GameObject(I).extend({&#x000A;    center: function() {&#x000A;      return Point(I.x + I.width / 2, I.y + I.height / 2);&#x000A;    }&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;Fan.sprites || (Fan.sprites = [Sprite.loadByName("crowd_1_s"), Sprite.loadByName("crowd_2_s")]);&#x000A;&#x000A;var FrameEditorState;&#x000A;&#x000A;FrameEditorState = function(I) {&#x000A;  var activeTool, addEventComponent, adjustComponentPosition, adjustComponentRotation, adjustComponentScale, characterActions, characterBodies, characterFacings, characterHeads, componentAt, constrainIndices, currentAction, currentAnimation, currentBody, currentFacing, currentFrameData, currentHead, currentTeam, data, defaultHeadData, drawBodySprite, drawComponentInfo, extractEventsData, extractHeadData, headDataObject, headPositions, helpInfo, lineHeight, loadFrameData, loadFromServer, namespace, p, saveToServer, screenCenter, selectedComponent, self, showHelp, storeFrameData, teamList, tools;&#x000A;  if (I == null) I = {};&#x000A;  Object.reverseMerge(I, {&#x000A;    frameIndex: 0,&#x000A;    facingIndex: 0,&#x000A;    actionIndex: 0,&#x000A;    headPositionIndex: 0,&#x000A;    bodyIndex: 0,&#x000A;    headIndex: 0,&#x000A;    teamIndex: 0&#x000A;  });&#x000A;  self = GameState(I);&#x000A;  screenCenter = Point(App.width, App.height).scale(0.5);&#x000A;  headPositions = 5;&#x000A;  namespace = ".FRAME_EDITOR";&#x000A;  teamList = ["spike", "smiley", "hiss", "mutant"];&#x000A;  characterHeads = ["bigeyes", "jawhead", "longface", "roundhead", "stubs"];&#x000A;  characterBodies = ["tubs", "skinny", "thick"];&#x000A;  characterActions = ["fast", "slow", "idle", "shoot", "fall"];&#x000A;  characterFacings = ["front", "back"];&#x000A;  showHelp = false;&#x000A;  helpInfo = {&#x000A;    F1: "Toggle help info",&#x000A;    "Arrow Keys": "Adjust component position"&#x000A;  };&#x000A;  p = null;&#x000A;  selectedComponent = null;&#x000A;  headDataObject = null;&#x000A;  addEventComponent = function(position) {&#x000A;    return selectedComponent = engine.add({&#x000A;      x: position.x,&#x000A;      y: position.y,&#x000A;      radius: 5,&#x000A;      color: "rgba(255, 0, 255, 0.5)",&#x000A;      name: "shoot",&#x000A;      type: "event"&#x000A;    });&#x000A;  };&#x000A;  componentAt = function(position) {&#x000A;    return headDataObject;&#x000A;  };&#x000A;  adjustComponentPosition = function(delta) {&#x000A;    return selectedComponent.position(selectedComponent.position().add(delta));&#x000A;  };&#x000A;  adjustComponentRotation = function(delta) {&#x000A;    return selectedComponent.I.rotation += delta;&#x000A;  };&#x000A;  adjustComponentScale = function(delta) {&#x000A;    if (selectedComponent.I.name === "shoot") {&#x000A;      return selectedComponent.I.radius += delta * 100;&#x000A;    } else {&#x000A;      return selectedComponent.I.scale += delta;&#x000A;    }&#x000A;  };&#x000A;  data = {};&#x000A;  tools = {};&#x000A;  defaultHeadData = function() {&#x000A;    return {&#x000A;      x: 32,&#x000A;      y: -64,&#x000A;      scale: 0.75,&#x000A;      rotation: 0&#x000A;    };&#x000A;  };&#x000A;  extractHeadData = function() {&#x000A;    var rotation, scale, x, y, _ref;&#x000A;    _ref = headDataObject.I, x = _ref.x, y = _ref.y, scale = _ref.scale, rotation = _ref.rotation;&#x000A;    if ((-0.001 < rotation && rotation < 0.001)) rotation = 0;&#x000A;    return {&#x000A;      x: x,&#x000A;      y: y,&#x000A;      scale: scale,&#x000A;      rotation: rotation&#x000A;    };&#x000A;  };&#x000A;  extractEventsData = function() {&#x000A;    return engine.find(".type=event").map(function(eventDatum) {&#x000A;      var name, radius, type, x, y, _ref;&#x000A;      _ref = eventDatum.I, x = _ref.x, y = _ref.y, radius = _ref.radius, name = _ref.name, type = _ref.type;&#x000A;      return {&#x000A;        x: x,&#x000A;        y: y,&#x000A;        radius: radius,&#x000A;        name: name,&#x000A;        type: type&#x000A;      };&#x000A;    });&#x000A;  };&#x000A;  constrainIndices = function() {&#x000A;    if (currentAnimation().length) {&#x000A;      I.frameIndex = I.frameIndex.mod(currentAnimation().length);&#x000A;    }&#x000A;    I.headPositionIndex = I.headPositionIndex.mod(headPositions);&#x000A;    I.actionIndex = I.actionIndex.mod(characterActions.length);&#x000A;    return I.facingIndex = I.facingIndex.mod(characterFacings.length);&#x000A;  };&#x000A;  currentTeam = function() {&#x000A;    return teamList.wrap(I.teamIndex);&#x000A;  };&#x000A;  currentBody = function() {&#x000A;    return characterBodies.wrap(I.bodyIndex);&#x000A;  };&#x000A;  currentHead = function() {&#x000A;    return characterHeads.wrap(I.headIndex);&#x000A;  };&#x000A;  currentAction = function() {&#x000A;    return characterActions.wrap(I.actionIndex);&#x000A;  };&#x000A;  currentFacing = function() {&#x000A;    return characterFacings.wrap(I.facingIndex);&#x000A;  };&#x000A;  currentAnimation = function() {&#x000A;    var _ref;&#x000A;    return (_ref = teamSprites[currentTeam()][currentBody()][currentAction()]) != null ? _ref[currentFacing()] : void 0;&#x000A;  };&#x000A;  currentFrameData = function(dataToSave) {&#x000A;    var _base, _base2, _name, _name2, _name3;&#x000A;    data[_name = currentAction()] || (data[_name] = {});&#x000A;    (_base = data[currentAction()])[_name2 = currentFacing()] || (_base[_name2] = []);&#x000A;    if (dataToSave != null) {&#x000A;      return data[currentAction()][currentFacing()][I.frameIndex] = dataToSave;&#x000A;    } else {&#x000A;      return (_base2 = data[currentAction()][currentFacing()])[_name3 = I.frameIndex] || (_base2[_name3] = {&#x000A;        head: defaultHeadData(),&#x000A;        events: []&#x000A;      });&#x000A;    }&#x000A;  };&#x000A;  loadFrameData = function() {&#x000A;    var d;&#x000A;    if (d = currentFrameData()) return Object.extend(headDataObject.I, d.head);&#x000A;  };&#x000A;  storeFrameData = function() {&#x000A;    var dataToSave;&#x000A;    dataToSave = {&#x000A;      head: extractHeadData(),&#x000A;      events: extractEventsData()&#x000A;    };&#x000A;    return currentFrameData(dataToSave);&#x000A;  };&#x000A;  saveToServer = function() {&#x000A;    return saveFile({&#x000A;      contents: JSON.stringify(data, null, 2),&#x000A;      path: "data/" + (currentTeam()) + "_" + (currentBody()) + ".json"&#x000A;    });&#x000A;  };&#x000A;  loadFromServer = function() {&#x000A;    var url;&#x000A;    url = ResourceLoader.urlFor("data", "" + (currentTeam()) + "_" + (currentBody()));&#x000A;    return $.getJSON(url, function(remoteData) {&#x000A;      console.log("received remote data");&#x000A;      console.log(remoteData);&#x000A;      data = remoteData;&#x000A;      return loadFrameData();&#x000A;    });&#x000A;  };&#x000A;  tools.move = (function() {&#x000A;    var activeComponent;&#x000A;    activeComponent = null;&#x000A;    return {&#x000A;      mousedown: function(_arg) {&#x000A;        var button, position;&#x000A;        position = _arg.position, button = _arg.button;&#x000A;        if (button === 1) {&#x000A;          return selectedComponent = activeComponent = componentAt(position);&#x000A;        } else if (button === 3) {&#x000A;          return addEventComponent(position);&#x000A;        }&#x000A;      },&#x000A;      mousemove: function(_arg) {&#x000A;        var position;&#x000A;        position = _arg.position;&#x000A;        if (activeComponent) return activeComponent.position(position);&#x000A;      },&#x000A;      mouseup: function() {&#x000A;        return activeComponent = null;&#x000A;      }&#x000A;    };&#x000A;  })();&#x000A;  activeTool = tools.move;&#x000A;  self.bind("enter", function() {&#x000A;    var addCycle, adjustIndexVariable, fn, hotkeys, key, shiftFactor, _results;&#x000A;    engine.cameras().first().I.scroll = Point(0, 0).subtract(screenCenter);&#x000A;    selectedComponent = headDataObject = engine.add({&#x000A;      x: 32,&#x000A;      y: -64,&#x000A;      rotation: 0,&#x000A;      radius: 5,&#x000A;      color: "cyan",&#x000A;      scale: 0.75,&#x000A;      type: "head"&#x000A;    });&#x000A;    headDataObject.bind("draw", function(canvas) {&#x000A;      var _ref;&#x000A;      return (_ref = teamSprites[currentTeam()][currentHead()].normal.wrap(I.headPositionIndex)) != null ? _ref.draw(canvas, -256, -256) : void 0;&#x000A;    });&#x000A;    p = engine.add({&#x000A;      id: 0,&#x000A;      "class": "Player",&#x000A;      joystick: true,&#x000A;      x: -screenCenter.x + 128,&#x000A;      y: screenCenter.y - 128&#x000A;    });&#x000A;    ["mousedown", "mousemove", "mouseup"].each(function(eventType) {&#x000A;      return $(document).bind("" + eventType + namespace, function(event) {&#x000A;        var button, position;&#x000A;        position = Point(event.pageX, event.pageY).subtract(screenCenter);&#x000A;        button = event.which;&#x000A;        return typeof activeTool[eventType] === "function" ? activeTool[eventType]({&#x000A;          position: position,&#x000A;          button: button&#x000A;        }) : void 0;&#x000A;      });&#x000A;    });&#x000A;    shiftFactor = 10;&#x000A;    hotkeys = {&#x000A;      "return": function() {&#x000A;        return console.log(JSON.stringify(data, null, 2));&#x000A;      },&#x000A;      f1: function() {&#x000A;        return showHelp = !showHelp;&#x000A;      },&#x000A;      "[": function() {&#x000A;        return adjustComponentRotation(-Math.TAU / 128);&#x000A;      },&#x000A;      "]": function() {&#x000A;        return adjustComponentRotation(Math.TAU / 128);&#x000A;      },&#x000A;      "-": function() {&#x000A;        return adjustComponentScale(-0.01);&#x000A;      },&#x000A;      "+": function() {&#x000A;        return adjustComponentScale(0.01);&#x000A;      },&#x000A;      "shift+-": function() {&#x000A;        return adjustComponentScale(-0.1);&#x000A;      },&#x000A;      "shift++": function() {&#x000A;        return adjustComponentScale(0.1);&#x000A;      },&#x000A;      insert: function() {&#x000A;        return selectedComponent = engine.add({&#x000A;          radius: 50,&#x000A;          color: "rgba(255, 0, 255, 0.5)",&#x000A;          rotation: 0,&#x000A;          scale: 1&#x000A;        });&#x000A;      },&#x000A;      "ctrl+s": function() {&#x000A;        return Local.set("characterData", data);&#x000A;      },&#x000A;      "ctrl+shift+s": function() {&#x000A;        return saveToServer();&#x000A;      },&#x000A;      "ctrl+l": function() {&#x000A;        data = Local.get("characterData") || {};&#x000A;        return loadFrameData();&#x000A;      },&#x000A;      "ctrl+shift+l": function() {&#x000A;        return loadFromServer();&#x000A;      }&#x000A;    };&#x000A;    ["left", "right", "up", "down"].each(function(direction) {&#x000A;      var point;&#x000A;      point = Point[direction.toUpperCase()];&#x000A;      hotkeys[direction] = function() {&#x000A;        return adjustComponentPosition(point);&#x000A;      };&#x000A;      return hotkeys["shift+" + direction] = function() {&#x000A;        return adjustComponentPosition(point.scale(shiftFactor));&#x000A;      };&#x000A;    });&#x000A;    adjustIndexVariable = function(variableName, amount) {&#x000A;      storeFrameData();&#x000A;      I[variableName] += amount;&#x000A;      constrainIndices();&#x000A;      return loadFrameData();&#x000A;    };&#x000A;    addCycle = function(variableName, prevKey, nextKey) {&#x000A;      hotkeys[prevKey] = function() {&#x000A;        return adjustIndexVariable(variableName, -1);&#x000A;      };&#x000A;      hotkeys[nextKey] = function() {&#x000A;        return adjustIndexVariable(variableName, 1);&#x000A;      };&#x000A;      helpInfo[prevKey] = "Decrement " + (variableName.underscore().humanize());&#x000A;      return helpInfo[nextKey] = "Increment " + (variableName.underscore().humanize());&#x000A;    };&#x000A;    addCycle("headPositionIndex", ";", "q");&#x000A;    addCycle("frameIndex", "v", "z");&#x000A;    addCycle("actionIndex", "pageup", "pagedown");&#x000A;    addCycle("facingIndex", "'", ",");&#x000A;    addCycle("bodyIndex", "j", "k");&#x000A;    addCycle("headIndex", "r", "l");&#x000A;    addCycle("teamIndex", "n", "s");&#x000A;    _results = [];&#x000A;    for (key in hotkeys) {&#x000A;      fn = hotkeys[key];&#x000A;      _results.push($(document).bind("keydown" + namespace, key, fn));&#x000A;    }&#x000A;    return _results;&#x000A;  });&#x000A;  self.bind("exit", function() {&#x000A;    return $(document).unbind(namespace);&#x000A;  });&#x000A;  drawBodySprite = function(canvas) {&#x000A;    return canvas.withTransform(Matrix.translation(screenCenter.x, screenCenter.y), function(canvas) {&#x000A;      var sprite, _ref;&#x000A;      if (sprite = (_ref = currentAnimation()) != null ? _ref.wrap(I.frameIndex) : void 0) {&#x000A;        return sprite.draw(canvas, -sprite.width / 2, -sprite.height / 2);&#x000A;      }&#x000A;    });&#x000A;  };&#x000A;  self.bind("beforeDraw", function(canvas) {&#x000A;    if (currentFacing() === "front") return drawBodySprite(canvas);&#x000A;  });&#x000A;  self.bind("draw", function(canvas) {&#x000A;    if (currentFacing() === "back") return drawBodySprite(canvas);&#x000A;  });&#x000A;  lineHeight = 30;&#x000A;  drawComponentInfo = function(canvas) {&#x000A;    var i, infoProps, prop, value, _len, _ref, _results;&#x000A;    if (selectedComponent) {&#x000A;      if (selectedComponent.I.name) {&#x000A;        infoProps = ["x", "y", "radius"];&#x000A;      } else {&#x000A;        infoProps = ["x", "y", "rotation", "scale"];&#x000A;      }&#x000A;      _results = [];&#x000A;      for (i = 0, _len = infoProps.length; i < _len; i++) {&#x000A;        prop = infoProps[i];&#x000A;        value = ((_ref = selectedComponent.I[prop]) != null ? typeof _ref.toFixed === "function" ? _ref.toFixed(3) : void 0 : void 0) || selectedComponent.I[prop];&#x000A;        canvas.drawText({&#x000A;          position: Point(0, lineHeight * i),&#x000A;          color: "white",&#x000A;          text: prop&#x000A;        });&#x000A;        _results.push(canvas.drawText({&#x000A;          position: Point(60, lineHeight * i),&#x000A;          color: "white",&#x000A;          text: value&#x000A;        }));&#x000A;      }&#x000A;      return _results;&#x000A;    }&#x000A;  };&#x000A;  self.bind("overlay", function(canvas) {&#x000A;    var description, key, y, _results;&#x000A;    canvas.drawText({&#x000A;      position: Point(60, 20),&#x000A;      color: "white",&#x000A;      text: "" + (currentTeam()) + " " + (currentBody())&#x000A;    });&#x000A;    canvas.drawText({&#x000A;      position: Point(140, 20),&#x000A;      color: "white",&#x000A;      text: currentFacing()&#x000A;    });&#x000A;    canvas.drawText({&#x000A;      position: Point(180, 20),&#x000A;      color: "white",&#x000A;      text: currentAction()&#x000A;    });&#x000A;    canvas.drawText({&#x000A;      position: Point(260, 20),&#x000A;      color: "white",&#x000A;      text: I.frameIndex&#x000A;    });&#x000A;    canvas.withTransform(Matrix.translation(30, 60), function(canvas) {&#x000A;      return drawComponentInfo(canvas);&#x000A;    });&#x000A;    if (showHelp) {&#x000A;      canvas.drawRect({&#x000A;        x: 0,&#x000A;        y: 0,&#x000A;        width: App.width,&#x000A;        height: App.height,&#x000A;        color: "rgba(0, 0, 0, 0.75)"&#x000A;      });&#x000A;      y = 80;&#x000A;      _results = [];&#x000A;      for (key in helpInfo) {&#x000A;        description = helpInfo[key];&#x000A;        canvas.drawText({&#x000A;          position: Point(200, y),&#x000A;          color: "white",&#x000A;          text: key&#x000A;        });&#x000A;        canvas.drawText({&#x000A;          position: Point(300, y),&#x000A;          color: "white",&#x000A;          text: description&#x000A;        });&#x000A;        _results.push(y += lineHeight);&#x000A;      }&#x000A;      return _results;&#x000A;    }&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var Gamepads;&#x000A;&#x000A;Gamepads = function(I) {&#x000A;  var controllers, snapshot, state;&#x000A;  if (I == null) I = {};&#x000A;  state = {};&#x000A;  controllers = [];&#x000A;  snapshot = function() {&#x000A;    return Array.prototype.map.call(navigator.webkitGamepads, function(x) {&#x000A;      return {&#x000A;        axes: x.axes,&#x000A;        buttons: x.buttons&#x000A;      };&#x000A;    });&#x000A;  };&#x000A;  return {&#x000A;    controller: function(index) {&#x000A;      if (index == null) index = 0;&#x000A;      return controllers[index] || (controllers[index] = Gamepads.Controller({&#x000A;        index: index,&#x000A;        state: state&#x000A;      }));&#x000A;    },&#x000A;    update: function() {&#x000A;      state.previous = state.current;&#x000A;      state.current = snapshot();&#x000A;      return controllers.each(function(controller) {&#x000A;        return controller != null ? controller.update() : void 0;&#x000A;      });&#x000A;    }&#x000A;  };&#x000A;};&#x000A;&#x000A;var __slice = Array.prototype.slice;&#x000A;&#x000A;Gamepads.Controller = function(I) {&#x000A;  var AXIS_MAX, BUTTON_THRESHOLD, DEAD_ZONE, MAX_BUFFER, TRIP_HIGH, TRIP_LOW, axisTrips, buttonMapping, currentState, previousState, processTaps, self, tap;&#x000A;  if (I == null) I = {};&#x000A;  Object.reverseMerge(I, {&#x000A;    debugColor: "#000"&#x000A;  });&#x000A;  MAX_BUFFER = 0.03;&#x000A;  AXIS_MAX = 1 - MAX_BUFFER;&#x000A;  DEAD_ZONE = AXIS_MAX * 0.2;&#x000A;  TRIP_HIGH = AXIS_MAX * 0.75;&#x000A;  TRIP_LOW = AXIS_MAX * 0.5;&#x000A;  BUTTON_THRESHOLD = 0.5;&#x000A;  buttonMapping = {&#x000A;    "A": 0,&#x000A;    "B": 1,&#x000A;    "C": 2,&#x000A;    "D": 3,&#x000A;    "X": 2,&#x000A;    "Y": 3,&#x000A;    "L": 4,&#x000A;    "LB": 4,&#x000A;    "L1": 4,&#x000A;    "R": 5,&#x000A;    "RB": 5,&#x000A;    "R1": 5,&#x000A;    "SELECT": 6,&#x000A;    "BACK": 6,&#x000A;    "START": 7,&#x000A;    "HOME": 8,&#x000A;    "GUIDE": 8,&#x000A;    "TL": 9,&#x000A;    "TR": 10&#x000A;  };&#x000A;  currentState = function() {&#x000A;    var _ref;&#x000A;    return (_ref = I.state.current) != null ? _ref[I.index] : void 0;&#x000A;  };&#x000A;  previousState = function() {&#x000A;    var _ref;&#x000A;    return (_ref = I.state.previous) != null ? _ref[I.index] : void 0;&#x000A;  };&#x000A;  axisTrips = [];&#x000A;  tap = Point(0, 0);&#x000A;  processTaps = function() {&#x000A;    var x, y, _ref;&#x000A;    _ref = [0, 1].map(function(n) {&#x000A;      if (!axisTrips[n] && self.axis(n).abs() > TRIP_HIGH) {&#x000A;        axisTrips[n] = true;&#x000A;        return self.axis(n).sign();&#x000A;      }&#x000A;      if (axisTrips[n] && self.axis(n).abs() < TRIP_LOW) axisTrips[n] = false;&#x000A;      return 0;&#x000A;    }), x = _ref[0], y = _ref[1];&#x000A;    return tap = Point(x, y);&#x000A;  };&#x000A;  return self = Core().include(Bindable).extend({&#x000A;    actionDown: function() {&#x000A;      var buttons, state;&#x000A;      buttons = 1 <= arguments.length ? __slice.call(arguments, 0) : [];&#x000A;      if (state = currentState()) {&#x000A;        return buttons.inject(false, function(down, button) {&#x000A;          return down || (button === "ANY" ? state.buttons.inject(false, function(down, button) {&#x000A;            return down || (button > BUTTON_THRESHOLD);&#x000A;          }) : state.buttons[buttonMapping[button]] > BUTTON_THRESHOLD);&#x000A;        });&#x000A;      } else {&#x000A;        return false;&#x000A;      }&#x000A;    },&#x000A;    buttonPressed: function(button) {&#x000A;      var buttonId;&#x000A;      buttonId = buttonMapping[button];&#x000A;      return (self.buttons()[buttonId] > BUTTON_THRESHOLD) && !(previousState().buttons[buttonId] > BUTTON_THRESHOLD);&#x000A;    },&#x000A;    position: function(stick) {&#x000A;      var magnitude, p, ratio, state;&#x000A;      if (stick == null) stick = 0;&#x000A;      if (state = currentState()) {&#x000A;        p = Point(self.axis(2 * stick), self.axis(2 * stick + 1));&#x000A;        magnitude = p.magnitude();&#x000A;        if (magnitude > AXIS_MAX) {&#x000A;          return p.norm();&#x000A;        } else if (magnitude < DEAD_ZONE) {&#x000A;          return Point(0, 0);&#x000A;        } else {&#x000A;          ratio = magnitude / AXIS_MAX;&#x000A;          return p.scale(ratio / AXIS_MAX);&#x000A;        }&#x000A;      } else {&#x000A;        return Point(0, 0);&#x000A;      }&#x000A;    },&#x000A;    axis: function(n) {&#x000A;      return self.axes()[n] || 0;&#x000A;    },&#x000A;    axes: function() {&#x000A;      var state;&#x000A;      if (state = currentState()) {&#x000A;        return state.axes;&#x000A;      } else {&#x000A;        return [];&#x000A;      }&#x000A;    },&#x000A;    buttons: function() {&#x000A;      var state;&#x000A;      if (state = currentState()) {&#x000A;        return state.buttons;&#x000A;      } else {&#x000A;        return [];&#x000A;      }&#x000A;    },&#x000A;    tap: function() {&#x000A;      return tap;&#x000A;    },&#x000A;    update: function() {&#x000A;      return processTaps();&#x000A;    },&#x000A;    drawDebug: function(canvas) {&#x000A;      var lineHeight;&#x000A;      lineHeight = 18;&#x000A;      self.axes().each(function(axis, i) {&#x000A;        return canvas.drawText({&#x000A;          color: I.debugColor,&#x000A;          text: axis,&#x000A;          x: 0,&#x000A;          y: i * lineHeight&#x000A;        });&#x000A;      });&#x000A;      return self.buttons().each(function(button, i) {&#x000A;        return canvas.drawText({&#x000A;          color: I.debugColor,&#x000A;          text: button,&#x000A;          x: 250,&#x000A;          y: i * lineHeight&#x000A;        });&#x000A;      });&#x000A;    }&#x000A;  });&#x000A;};&#x000A;&#x000A;var Goal;&#x000A;&#x000A;Goal = function(I) {&#x000A;  var DEBUG_DRAW, HEIGHT, WALL_RADIUS, WIDTH, drawWall, self, walls;&#x000A;  I || (I = {});&#x000A;  DEBUG_DRAW = false;&#x000A;  WALL_RADIUS = 2;&#x000A;  WIDTH = 32;&#x000A;  HEIGHT = 60;&#x000A;  Goal.netSprites || (Goal.netSprites = Sprite.loadSheet("goal_lasnet", 640, 640, 0.25));&#x000A;  Object.reverseMerge(I, {&#x000A;    height: HEIGHT,&#x000A;    width: WIDTH,&#x000A;    x: WALL_LEFT + ARENA_WIDTH / 20 - WIDTH,&#x000A;    y: WALL_TOP + ARENA_HEIGHT / 2 - HEIGHT / 2,&#x000A;    spriteOffset: Point(6, -HEIGHT / 2 - 8),&#x000A;    suddenDeath: false,&#x000A;    team: "mutant"&#x000A;  });&#x000A;  I.hflip = I.right;&#x000A;  if (!I.right) I.team = "hiss";&#x000A;  walls = [];&#x000A;  if (I.right) {&#x000A;    walls.push({&#x000A;      center: Point(I.x + I.width, I.y + I.height / 2),&#x000A;      halfWidth: WALL_RADIUS,&#x000A;      halfHeight: I.height / 2,&#x000A;      killSide: -1&#x000A;    });&#x000A;  } else {&#x000A;    walls.push({&#x000A;      center: Point(I.x, I.y + I.height / 2),&#x000A;      halfWidth: WALL_RADIUS,&#x000A;      halfHeight: I.height / 2,&#x000A;      killSide: 1&#x000A;    });&#x000A;  }&#x000A;  walls.push({&#x000A;    center: Point(I.x + I.width / 2, I.y),&#x000A;    halfWidth: I.width / 2,&#x000A;    halfHeight: WALL_RADIUS,&#x000A;    horizontal: true&#x000A;  }, {&#x000A;    center: Point(I.x + I.width / 2, I.y + I.height),&#x000A;    halfWidth: I.width / 2,&#x000A;    halfHeight: WALL_RADIUS,&#x000A;    horizontal: true&#x000A;  });&#x000A;  drawWall = function(wall, canvas) {&#x000A;    return canvas.drawRect({&#x000A;      color: "#0F0",&#x000A;      x: wall.center.x - wall.halfWidth,&#x000A;      y: wall.center.y - wall.halfHeight,&#x000A;      width: 2 * wall.halfWidth,&#x000A;      height: 2 * wall.halfHeight&#x000A;    });&#x000A;  };&#x000A;  self = GameObject(I).extend({&#x000A;    center: function() {&#x000A;      return Point(I.x + I.width / 2, I.y + I.height / 2);&#x000A;    },&#x000A;    walls: function() {&#x000A;      return walls;&#x000A;    },&#x000A;    withinGoal: function(circle) {&#x000A;      if (circle.x - circle.radius > I.x && circle.x + circle.radius < I.x + I.width) {&#x000A;        if (circle.y - circle.radius > I.y && circle.y + circle.radius < I.y + I.height) {&#x000A;          return true;&#x000A;        }&#x000A;      }&#x000A;      return false;&#x000A;    },&#x000A;    score: function() {&#x000A;      self.trigger("score");&#x000A;      Sound.play("crowd" + (rand(3)));&#x000A;      Sound.play("siren");&#x000A;      if (I.suddenDeath) return self.destroy();&#x000A;    }&#x000A;  });&#x000A;  self.bind("destroy", function() {&#x000A;    return engine.add({&#x000A;      "class": "Shockwave",&#x000A;      x: I.x + I.width / 2,&#x000A;      y: I.y + I.height / 2,&#x000A;      velocity: Point(0, 1)&#x000A;    });&#x000A;  });&#x000A;  self.bind("drawDebug", function(canvas) {&#x000A;    canvas.drawRect({&#x000A;      bounds: I,&#x000A;      color: "rgba(255, 0, 255, 0.5)"&#x000A;    });&#x000A;    return walls.each(function(wall) {&#x000A;      return drawWall(wall, canvas);&#x000A;    });&#x000A;  });&#x000A;  self.bind("step", function() {&#x000A;    I.sprite = teamSprites[I.team].goal.back[0];&#x000A;    return I.zIndex = 1 + (I.y + I.height) / CANVAS_HEIGHT;&#x000A;  });&#x000A;  self.unbind("draw");&#x000A;  self.bind("draw", function(canvas) {&#x000A;    var netSprite, sprite;&#x000A;    if (sprite = teamSprites[I.team].goal.back[0]) {&#x000A;      sprite.draw(canvas, -sprite.width / 2, -sprite.height / 2);&#x000A;    }&#x000A;    if (sprite = teamSprites[I.team].goal.front[0]) {&#x000A;      sprite.draw(canvas, -sprite.width / 2, -sprite.height / 2);&#x000A;    }&#x000A;    if (netSprite = Goal.netSprites[0]) {&#x000A;      return netSprite.draw(canvas, -netSprite.width / 2, -netSprite.height / 2);&#x000A;    }&#x000A;  });&#x000A;  self.attrReader("team");&#x000A;  self.attrAccessor("suddenDeath");&#x000A;  return self;&#x000A;};&#x000A;&#x000A;&#x000A;window.onerror = function(message, url, lineNumber) {&#x000A;  var errorContext;&#x000A;  errorContext = $('script').last().text().split('\n').slice(lineNumber - 5, (lineNumber + 4) + 1 || 9e9);&#x000A;  errorContext[4] = "<b style='font-weight: bold; text-decoration: underline;'>" + errorContext[4] + "</b>";&#x000A;  return typeof displayRuntimeError === "function" ? displayRuntimeError("<code>" + message + "</code> <br /><br />(Sometimes this context may be wrong.)<br /><code><pre>" + (errorContext.join('\n')) + "</pre></code>") : void 0;&#x000A;};&#x000A;&#x000A;var HeadSheet;&#x000A;&#x000A;HeadSheet = function(I) {&#x000A;  var actions, loadStrip, self;&#x000A;  if (I == null) I = {};&#x000A;  Object.reverseMerge(I, {&#x000A;    character: "bigeyes",&#x000A;    team: "spike",&#x000A;    size: 512&#x000A;  });&#x000A;  loadStrip = function(action, cells) {&#x000A;    if (action) {&#x000A;      return Sprite.loadSheet("" + I.team + "_" + I.character + "_" + action + "_" + cells, I.size, I.size, 0.5);&#x000A;    } else {&#x000A;      return Sprite.loadSheet("" + I.team + "_" + I.character + "_" + cells, I.size, I.size, 0.5);&#x000A;    }&#x000A;  };&#x000A;  actions = ["charged", "pain"];&#x000A;  self = {};&#x000A;  actions.each(function(action) {&#x000A;    return self[action] = loadStrip(action, 5);&#x000A;  });&#x000A;  self.normal = loadStrip(null, 5);&#x000A;  return self;&#x000A;};&#x000A;&#x000A;&#x000A;var MainMenuState;&#x000A;&#x000A;MainMenuState = function(I) {&#x000A;  var self;&#x000A;  if (I == null) I = {};&#x000A;  self = GameState(I);&#x000A;  self.bind("enter", function() {&#x000A;    rink.hide();&#x000A;    engine.add({&#x000A;      "class": "Menu"&#x000A;    });&#x000A;    return engine.add({&#x000A;      sprite: "title_text",&#x000A;      x: App.width / 2,&#x000A;      y: App.height / 3 - 50&#x000A;    });&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var MatchSetupState;&#x000A;&#x000A;MatchSetupState = function(I) {&#x000A;  var initPlayerData, self;&#x000A;  if (I == null) I = {};&#x000A;  self = GameState(I);&#x000A;  initPlayerData = function() {&#x000A;    MAX_PLAYERS.times(function(i) {&#x000A;      var _base;&#x000A;      $.reverseMerge((_base = config.players)[i] || (_base[i] = {}), {&#x000A;        "class": "Player",&#x000A;        color: Player.COLORS[i],&#x000A;        id: i,&#x000A;        name: "",&#x000A;        teamIndex: i % 2,&#x000A;        joystick: window.config.joysticks,&#x000A;        cpu: true,&#x000A;        bodyIndex: rand(TeamSheet.bodyStyles.length),&#x000A;        headIndex: rand(TeamSheet.headStyles.length)&#x000A;      });&#x000A;      return $.extend(config.players[i], {&#x000A;        ready: false,&#x000A;        cpu: true&#x000A;      });&#x000A;    });&#x000A;    return config;&#x000A;  };&#x000A;  self.bind("enter", function() {&#x000A;    var configurator;&#x000A;    engine.clear(false);&#x000A;    rink.hide();&#x000A;    if (config.music) {&#x000A;      Music.volume(0.4);&#x000A;      Music.play("title_screen");&#x000A;    }&#x000A;    configurator = engine.add({&#x000A;      "class": "Configurator",&#x000A;      config: initPlayerData()&#x000A;    });&#x000A;    return configurator.bind("done", function(config) {&#x000A;      configurator.destroy();&#x000A;      return engine.setState(MatchState());&#x000A;    });&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var MatchState;&#x000A;&#x000A;MatchState = function(I) {&#x000A;  var physics, self;&#x000A;  if (I == null) I = {};&#x000A;  self = GameState(I);&#x000A;  physics = Physics();&#x000A;  self.bind("enter", function() {&#x000A;    var leftGoal, rightGoal, scoreboard;&#x000A;    engine.clear(true);&#x000A;    rink.show();&#x000A;    scoreboard = engine.add({&#x000A;      "class": "Scoreboard"&#x000A;    });&#x000A;    scoreboard.bind("restart", function() {&#x000A;      return engine.setState(MatchSetupState());&#x000A;    });&#x000A;    config.players.each(function(playerData) {&#x000A;      return engine.add($.extend({}, playerData));&#x000A;    });&#x000A;    engine.add({&#x000A;      "class": "Puck"&#x000A;    });&#x000A;    leftGoal = engine.add({&#x000A;      "class": "Goal",&#x000A;      right: false,&#x000A;      x: WALL_LEFT + ARENA_WIDTH / 10 - 32&#x000A;    });&#x000A;    leftGoal.bind("score", function() {&#x000A;      return scoreboard.score("home");&#x000A;    });&#x000A;    rightGoal = engine.add({&#x000A;      "class": "Goal",&#x000A;      right: true,&#x000A;      x: WALL_LEFT + ARENA_WIDTH * 9 / 10&#x000A;    });&#x000A;    rightGoal.bind("score", function() {&#x000A;      return scoreboard.score("away");&#x000A;    });&#x000A;    if (config.music) return Music.play("music1");&#x000A;  });&#x000A;  self.bind("update", function() {&#x000A;    var objects, players, playersAndPucks, pucks, zambonis;&#x000A;    pucks = engine.find("Puck");&#x000A;    players = engine.find("Player").shuffle();&#x000A;    zambonis = engine.find("Zamboni");&#x000A;    objects = players.concat(zambonis, pucks);&#x000A;    playersAndPucks = players.concat(pucks);&#x000A;    players.each(function(player) {&#x000A;      if (player.I.wipeout) return;&#x000A;      return pucks.each(function(puck) {&#x000A;        if (Collision.circular(player.controlCircle(), puck.circle())) {&#x000A;          return player.controlPuck(puck);&#x000A;        }&#x000A;      });&#x000A;    });&#x000A;    physics.process(objects);&#x000A;    return playersAndPucks.each(function(player) {&#x000A;      var splats;&#x000A;      splats = engine.find("Blood");&#x000A;      return splats.each(function(splat) {&#x000A;        if (Collision.circular(player.circle(), splat.circle())) {&#x000A;          return player.bloody();&#x000A;        }&#x000A;      });&#x000A;    });&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var Menu;&#x000A;&#x000A;Menu = function(I) {&#x000A;  var choose, moveSelection, self;&#x000A;  if (I == null) I = {};&#x000A;  Object.reverseMerge(I, {&#x000A;    x: App.width / 2,&#x000A;    y: 2 * App.height / 3 + 32,&#x000A;    sprite: "menu_border_1",&#x000A;    selectedOption: 0,&#x000A;    options: [&#x000A;      {&#x000A;        text: "Versus",&#x000A;        action: function() {&#x000A;          return engine.setState(MatchSetupState());&#x000A;        }&#x000A;      }, {&#x000A;        text: "Mini-Games",&#x000A;        action: function() {}&#x000A;      }, {&#x000A;        text: "Options",&#x000A;        action: function() {}&#x000A;      }&#x000A;    ]&#x000A;  });&#x000A;  self = GameObject(I);&#x000A;  moveSelection = function(change) {&#x000A;    I.selectedOption += change;&#x000A;    return I.selectedOption = I.selectedOption.mod(I.options.length);&#x000A;  };&#x000A;  choose = function() {&#x000A;    return I.options[I.selectedOption].action();&#x000A;  };&#x000A;  self.bind("update", function() {&#x000A;    if (justPressed.up) moveSelection(-1);&#x000A;    if (justPressed.down) moveSelection(1);&#x000A;    if (justPressed["return"]) choose();&#x000A;    return MAX_PLAYERS.times(function(i) {&#x000A;      var joystick;&#x000A;      joystick = engine.controller(i);&#x000A;      moveSelection(joystick.tap().y);&#x000A;      if (joystick.buttonPressed("A")) return choose();&#x000A;    });&#x000A;  });&#x000A;  self.unbind("draw");&#x000A;  self.bind("draw", function(canvas) {&#x000A;    var sprite;&#x000A;    sprite = Menu.topSprite;&#x000A;    sprite.draw(canvas, -sprite.width / 2, -sprite.height);&#x000A;    sprite = Menu.middleSprite;&#x000A;    sprite.draw(canvas, -sprite.width / 2, 0);&#x000A;    sprite = Menu.bottomSprite;&#x000A;    sprite.draw(canvas, -sprite.width / 2, 128);&#x000A;    canvas.font("bold 48px consolas, 'Courier New', 'andale mono', 'lucida console', monospace");&#x000A;    return I.options.each(function(option, i) {&#x000A;      var width;&#x000A;      canvas.centerText({&#x000A;        text: option.text,&#x000A;        x: 0,&#x000A;        y: i * 64,&#x000A;        color: "white"&#x000A;      });&#x000A;      if (i === I.selectedOption) {&#x000A;        width = 256 + 128;&#x000A;        return canvas.drawRect({&#x000A;          x: -width / 2,&#x000A;          y: i * 64 - 30,&#x000A;          width: width,&#x000A;          height: 32,&#x000A;          color: "rgba(255, 0, 255, 0.25)"&#x000A;        });&#x000A;      }&#x000A;    });&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;Menu.topSprite = Sprite.loadByName("menu_border_1");&#x000A;&#x000A;Menu.middleSprite = Sprite.loadByName("menu_border_2");&#x000A;&#x000A;Menu.bottomSprite = Sprite.loadByName("menu_border_3");&#x000A;&#x000A;var NameEntry;&#x000A;&#x000A;NameEntry = function(I) {&#x000A;  var addCharacter, characterAtCursor, cols, controller, horizontalPadding, lineHeight, margin, menuArea, move, nameArea, rows, self, textArea, textAreaHeight, verticalPadding, width;&#x000A;  $.reverseMerge(I, {&#x000A;    backgroundColor: "rgba(0, 255, 255, 0.5)",&#x000A;    characterSet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 _-.!?".split(""),&#x000A;    cellWidth: 20,&#x000A;    cellHeight: 20,&#x000A;    textColor: "#FFF",&#x000A;    cols: 8,&#x000A;    cursorColor: "rgba(0, 255, 0, 0.5)",&#x000A;    cursor: {&#x000A;      x: 0,&#x000A;      y: 0,&#x000A;      menu: false&#x000A;    },&#x000A;    font: "bold 14px 'Monaco', 'Inconsolata', 'consolas', 'Courier New', 'andale mono', 'lucida console', 'monospace'",&#x000A;    name: "",&#x000A;    maxLength: 8,&#x000A;    controller: null&#x000A;  });&#x000A;  lineHeight = 11;&#x000A;  verticalPadding = 4;&#x000A;  horizontalPadding = 6;&#x000A;  margin = 6;&#x000A;  if (I.controller != null) controller = engine.controller(I.controller);&#x000A;  cols = function() {&#x000A;    return I.cols;&#x000A;  };&#x000A;  rows = function() {&#x000A;    return (I.characterSet.length / I.cols).ceil();&#x000A;  };&#x000A;  width = function() {&#x000A;    return cols() * I.cellWidth;&#x000A;  };&#x000A;  textAreaHeight = function() {&#x000A;    return I.cellHeight * rows();&#x000A;  };&#x000A;  move = function(delta) {&#x000A;    var newY, _results, _results2;&#x000A;    I.cursor.x = (I.cursor.x + delta.x).mod(cols());&#x000A;    newY = I.cursor.y + delta.y;&#x000A;    if (I.cursor.menu && newY) {&#x000A;      I.cursor.menu = false;&#x000A;      if (newY > 0) newY = 0;&#x000A;      I.cursor.y = newY.mod(rows());&#x000A;    } else if ((newY === -1) || (newY === rows())) {&#x000A;      I.cursor.menu = true;&#x000A;      I.cursor.y = 0;&#x000A;    } else {&#x000A;      I.cursor.y = newY.mod(rows());&#x000A;    }&#x000A;    if (!I.cursor.menu && characterAtCursor() === void 0) {&#x000A;      if (delta.x > 0) {&#x000A;        _results = [];&#x000A;        while (characterAtCursor() === void 0) {&#x000A;          _results.push(I.cursor.x = (I.cursor.x + 1) % rows());&#x000A;        }&#x000A;        return _results;&#x000A;      } else {&#x000A;        _results2 = [];&#x000A;        while (characterAtCursor() === void 0) {&#x000A;          _results2.push(I.cursor.x = (I.cursor.x - 1) % rows());&#x000A;        }&#x000A;        return _results2;&#x000A;      }&#x000A;    }&#x000A;  };&#x000A;  characterAtCursor = function() {&#x000A;    return I.characterSet[I.cursor.x + I.cursor.y * I.cols];&#x000A;  };&#x000A;  addCharacter = function() {&#x000A;    if (I.cursor.menu) {&#x000A;      return self.trigger("done", I.name);&#x000A;    } else {&#x000A;      if (I.name.length < I.maxLength) {&#x000A;        I.name += characterAtCursor();&#x000A;        self.trigger("change", I.name);&#x000A;      }&#x000A;      if (I.name.length === I.maxLength) {&#x000A;        I.cursor.menu = true;&#x000A;        I.cursor.y = 0;&#x000A;        return I.cursor.x = 0;&#x000A;      }&#x000A;    }&#x000A;  };&#x000A;  nameArea = {&#x000A;    draw: function(canvas) {&#x000A;      var cursorHeight, cursorWidth, nameAreaWidth;&#x000A;      cursorWidth = 10;&#x000A;      cursorHeight = 2;&#x000A;      nameAreaWidth = canvas.measureText(["M"].wrap(0, I.maxLength).join("")) + 2 * horizontalPadding;&#x000A;      return canvas.withTransform(Matrix.translation(this.x, this.y), function() {&#x000A;        var nameWidth;&#x000A;        canvas.drawRoundRect({&#x000A;          x: 0,&#x000A;          y: 0,&#x000A;          width: nameAreaWidth,&#x000A;          height: I.cellHeight,&#x000A;          color: I.backgroundColor&#x000A;        });&#x000A;        canvas.drawText({&#x000A;          text: I.name,&#x000A;          color: I.textColor,&#x000A;          position: Point(horizontalPadding, lineHeight + verticalPadding)&#x000A;        });&#x000A;        if ((I.age / 20).floor() % 2) {&#x000A;          if (I.name.length === I.maxLength) {&#x000A;            nameWidth = canvas.measureText(I.name.substring(0, I.name.length - 1));&#x000A;          } else {&#x000A;            nameWidth = canvas.measureText(I.name);&#x000A;          }&#x000A;          return canvas.drawRect({&#x000A;            x: nameWidth + horizontalPadding,&#x000A;            y: verticalPadding + lineHeight,&#x000A;            width: cursorWidth,&#x000A;            height: cursorHeight,&#x000A;            color: I.cursorColor&#x000A;          });&#x000A;        }&#x000A;      });&#x000A;    },&#x000A;    x: 0,&#x000A;    y: 0&#x000A;  };&#x000A;  textArea = {&#x000A;    draw: function(canvas) {&#x000A;      return canvas.withTransform(Matrix.translation(this.x, this.y), function() {&#x000A;        var row;&#x000A;        canvas.drawRoundRect({&#x000A;          x: 0,&#x000A;          y: 0,&#x000A;          width: width(),&#x000A;          height: textAreaHeight(),&#x000A;          color: I.backgroundColor&#x000A;        });&#x000A;        row = 0;&#x000A;        I.characterSet.each(function(c, i) {&#x000A;          var col;&#x000A;          col = i % I.cols;&#x000A;          row = (i / I.cols).floor();&#x000A;          return canvas.drawText({&#x000A;            text: c,&#x000A;            color: I.textColor,&#x000A;            x: col * I.cellWidth + horizontalPadding,&#x000A;            y: row * I.cellHeight + lineHeight + verticalPadding&#x000A;          });&#x000A;        });&#x000A;        row += 1;&#x000A;        if (!I.cursor.menu) {&#x000A;          return canvas.drawRoundRect({&#x000A;            color: I.cursorColor,&#x000A;            x: I.cursor.x * I.cellWidth,&#x000A;            y: I.cursor.y * I.cellHeight,&#x000A;            width: I.cellWidth,&#x000A;            height: I.cellHeight&#x000A;          });&#x000A;        }&#x000A;      });&#x000A;    },&#x000A;    x: 0,&#x000A;    y: I.cellHeight + margin&#x000A;  };&#x000A;  menuArea = {&#x000A;    draw: function(canvas) {&#x000A;      return canvas.withTransform(Matrix.translation(this.x, this.y), function() {&#x000A;        var option, optionWidth;&#x000A;        option = "Done";&#x000A;        optionWidth = canvas.measureText(option);&#x000A;        canvas.drawText({&#x000A;          text: option,&#x000A;          color: I.textColor,&#x000A;          x: horizontalPadding,&#x000A;          y: lineHeight + verticalPadding&#x000A;        });&#x000A;        if (I.cursor.menu) {&#x000A;          return canvas.drawRoundRect({&#x000A;            color: I.cursorColor,&#x000A;            x: 0,&#x000A;            y: 0,&#x000A;            width: optionWidth + 2 * horizontalPadding,&#x000A;            height: I.cellHeight&#x000A;          });&#x000A;        }&#x000A;      });&#x000A;    },&#x000A;    x: 0,&#x000A;    y: I.cellHeight * (rows() + 1) + 2 * margin&#x000A;  };&#x000A;  self = GameObject(I).extend({&#x000A;    draw: function(canvas) {&#x000A;      return canvas.withTransform(self.transform(), function(canvas) {&#x000A;        canvas.font(I.font);&#x000A;        textArea.draw(canvas);&#x000A;        return menuArea.draw(canvas);&#x000A;      });&#x000A;    }&#x000A;  });&#x000A;  self.bind("step", function() {&#x000A;    if (justPressed.left) move(Point(-1, 0));&#x000A;    if (justPressed.right) move(Point(1, 0));&#x000A;    if (justPressed.up) move(Point(0, -1));&#x000A;    if (justPressed.down) move(Point(0, 1));&#x000A;    if (justPressed["return"]) addCharacter();&#x000A;    if (justPressed.backspace) I.name = I.name.substring(0, I.name.length - 1);&#x000A;    if (controller != null ? controller.buttonPressed("A") : void 0) {&#x000A;      addCharacter();&#x000A;    }&#x000A;    if (controller != null ? controller.buttonPressed("B") : void 0) {&#x000A;      I.name = I.name.substring(0, I.name.length - 1);&#x000A;      self.trigger("change", I.name);&#x000A;    }&#x000A;    if (controller) return move(controller.tap());&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var Physics;&#x000A;&#x000A;Physics = function() {&#x000A;  var cornerRadius, corners, overlapX, overlapY, rectangularOverlap, resolveCollision, resolveCollisions, threshold, wallCollisions, walls;&#x000A;  overlapX = function(wall, circle) {&#x000A;    return (circle.x - wall.center.x).abs() < wall.halfWidth + circle.radius;&#x000A;  };&#x000A;  overlapY = function(wall, circle) {&#x000A;    return (circle.y - wall.center.y).abs() < wall.halfHeight + circle.radius;&#x000A;  };&#x000A;  rectangularOverlap = function(wall, circle) {&#x000A;    return overlapX(wall, circle) && overlapY(wall, circle);&#x000A;  };&#x000A;  walls = [&#x000A;    {&#x000A;      normal: Point(1, 0),&#x000A;      position: WALL_LEFT&#x000A;    }, {&#x000A;      normal: Point(-1, 0),&#x000A;      position: -WALL_RIGHT&#x000A;    }, {&#x000A;      normal: Point(0, 1),&#x000A;      position: WALL_TOP&#x000A;    }, {&#x000A;      normal: Point(0, -1),&#x000A;      position: -WALL_BOTTOM&#x000A;    }&#x000A;  ];&#x000A;  cornerRadius = Rink.CORNER_RADIUS;&#x000A;  corners = [&#x000A;    {&#x000A;      position: Point(WALL_LEFT + cornerRadius, WALL_TOP + cornerRadius),&#x000A;      quadrant: 0&#x000A;    }, {&#x000A;      position: Point(WALL_RIGHT - cornerRadius, WALL_TOP + cornerRadius),&#x000A;      quadrant: 1&#x000A;    }, {&#x000A;      position: Point(WALL_LEFT + cornerRadius, WALL_BOTTOM - cornerRadius),&#x000A;      quadrant: -1&#x000A;    }, {&#x000A;      position: Point(WALL_RIGHT - cornerRadius, WALL_BOTTOM - cornerRadius),&#x000A;      quadrant: -2&#x000A;    }&#x000A;  ];&#x000A;  threshold = 12;&#x000A;  resolveCollision = function(A, B) {&#x000A;    var massA, massB, max, normal, powA, powB, pushA, pushB, relativeVelocity, totalMass;&#x000A;    normal = B.center().subtract(A.center()).norm();&#x000A;    powA = A.collisionPower(normal);&#x000A;    powB = -B.collisionPower(normal);&#x000A;    max = Math.max(powA, powB);&#x000A;    if (max > threshold) {&#x000A;      if (powA === max) {&#x000A;        A.crush(B);&#x000A;        B.wipeout(normal);&#x000A;      } else {&#x000A;        B.crush(A);&#x000A;        A.wipeout(normal.scale(-1));&#x000A;      }&#x000A;    }&#x000A;    relativeVelocity = A.I.velocity.subtract(B.I.velocity);&#x000A;    massA = A.mass();&#x000A;    massB = B.mass();&#x000A;    totalMass = massA + massB;&#x000A;    pushA = normal.scale(-2 * (relativeVelocity.dot(normal) * (massB / totalMass) + 1));&#x000A;    pushB = normal.scale(+2 * (relativeVelocity.dot(normal) * (massA / totalMass) + 1));&#x000A;    A.I.velocity = A.I.velocity.add(pushA);&#x000A;    return B.I.velocity = B.I.velocity.add(pushB);&#x000A;  };&#x000A;  resolveCollisions = function(objects) {&#x000A;    return objects.eachPair(function(a, b) {&#x000A;      if (!(a.collides() && b.collides())) return;&#x000A;      if (Collision.circular(a.circle(), b.circle())) {&#x000A;        return resolveCollision(a, b);&#x000A;      }&#x000A;    });&#x000A;  };&#x000A;  wallCollisions = function(objects, dt) {&#x000A;    var wallSegments;&#x000A;    wallSegments = engine.find("Goal").map(function(goal) {&#x000A;      return goal.walls();&#x000A;    }).flatten();&#x000A;    objects.each(function(object) {&#x000A;      var center, circle, collided, radius, velocity;&#x000A;      if (!object.collidesWithWalls()) return;&#x000A;      center = circle = object.circle();&#x000A;      radius = circle.radius;&#x000A;      velocity = object.I.velocity;&#x000A;      collided = false;&#x000A;      wallSegments.each(function(wall) {&#x000A;        var capCenter, normal, velocityProjection, wallToObject;&#x000A;        if (rectangularOverlap(wall, circle)) {&#x000A;          wallToObject = center.subtract(wall.center);&#x000A;          if (wall.horizontal) {&#x000A;            if (wallToObject.x.abs() < wall.halfWidth) {&#x000A;              normal = Point(0, wallToObject.y.sign());&#x000A;            } else {&#x000A;              capCenter = Point(wallToObject.x.sign() * wall.halfWidth, 0).add(wall.center);&#x000A;              normal = center.subtract(capCenter).norm();&#x000A;            }&#x000A;          } else {&#x000A;            normal = Point(wallToObject.x.sign(), 0);&#x000A;          }&#x000A;          velocityProjection = velocity.dot(normal);&#x000A;          if (velocityProjection < 0) {&#x000A;            velocity = velocity.subtract(normal.scale(2 * velocityProjection));&#x000A;            return collided = true;&#x000A;          }&#x000A;        }&#x000A;      });&#x000A;      if (collided) {&#x000A;        object.I.velocity = velocity;&#x000A;        object.updatePosition(dt, true);&#x000A;        object.trigger("wallCollision");&#x000A;        if (object.puck()) Sound.play("clink0");&#x000A;      }&#x000A;    });&#x000A;    objects.each(function(object) {&#x000A;      var center, radius, velocity;&#x000A;      if (!object.collidesWithWalls()) return;&#x000A;      center = object.center();&#x000A;      radius = object.I.radius;&#x000A;      velocity = object.I.velocity;&#x000A;      corners.each(function(corner) {&#x000A;        var angle, distanceToCenter, normal, position, quadrant, velocityProjection;&#x000A;        position = corner.position;&#x000A;        switch (corner.quadrant) {&#x000A;          case 0:&#x000A;            if (!(center.x < position.x && center.y < position.y)) return;&#x000A;            break;&#x000A;          case 1:&#x000A;            if (!(center.x > position.x && center.y < position.y)) return;&#x000A;            break;&#x000A;          case -1:&#x000A;            if (!(center.x < position.x && center.y > position.y)) return;&#x000A;            break;&#x000A;          case -2:&#x000A;            if (!(center.x > position.x && center.y > position.y)) return;&#x000A;        }&#x000A;        distanceToCenter = position.subtract(center);&#x000A;        normal = distanceToCenter.norm();&#x000A;        angle = Point.direction(Point(0, 0), normal);&#x000A;        quadrant = (4 * angle / Math.TAU).floor();&#x000A;        if (quadrant === corner.quadrant && radius * radius + distanceToCenter.dot(distanceToCenter) > cornerRadius * cornerRadius) {&#x000A;          velocityProjection = velocity.dot(normal);&#x000A;          if (velocityProjection < 0) {&#x000A;            velocity = velocity.subtract(normal.scale(2 * velocityProjection));&#x000A;            object.I.velocity = velocity;&#x000A;            object.updatePosition(dt, true);&#x000A;            object.trigger("wallCollision");&#x000A;            if (object.puck()) return Sound.play("thud0");&#x000A;          }&#x000A;        }&#x000A;      });&#x000A;    });&#x000A;    return objects.each(function(object) {&#x000A;      var center, collided, radius, velocity;&#x000A;      if (!object.collidesWithWalls()) return;&#x000A;      center = object.center();&#x000A;      radius = object.I.radius;&#x000A;      velocity = object.I.velocity;&#x000A;      collided = false;&#x000A;      walls.each(function(wall) {&#x000A;        var normal, position, velocityProjection;&#x000A;        position = wall.position, normal = wall.normal;&#x000A;        if (center.dot(normal) < radius + position) {&#x000A;          velocityProjection = velocity.dot(normal);&#x000A;          if (velocityProjection < 0) {&#x000A;            velocity = velocity.subtract(normal.scale(2 * velocityProjection));&#x000A;            return collided = true;&#x000A;          }&#x000A;        }&#x000A;      });&#x000A;      if (collided) {&#x000A;        object.I.velocity = velocity;&#x000A;        object.updatePosition(dt, true);&#x000A;        object.trigger("wallCollision");&#x000A;        if (object.puck()) Sound.play("thud0");&#x000A;      }&#x000A;    });&#x000A;  };&#x000A;  return {&#x000A;    process: function(objects) {&#x000A;      var dt, steps;&#x000A;      steps = 5;&#x000A;      dt = 1 / steps;&#x000A;      return steps.times(function() {&#x000A;        objects.invoke("updatePosition", dt);&#x000A;        resolveCollisions(objects, dt);&#x000A;        return wallCollisions(objects, dt);&#x000A;      });&#x000A;    }&#x000A;  };&#x000A;};&#x000A;&#x000A;var __slice = Array.prototype.slice;&#x000A;&#x000A;(function($) {&#x000A;  return $.fn.pixieCanvas = function(options) {&#x000A;    var $canvas, canvas, canvasAttrAccessor, context, contextAttrAccessor;&#x000A;    options || (options = {});&#x000A;    canvas = this.get(0);&#x000A;    context = void 0;</code></pre>
        </section>
      </div>
      <hr />
    </div>
  </body>
</html>
<script type='text/javascript'>
  //<![CDATA[
    $(function() {
      $(".documentation").on("click", ".toggle_source", function(e) {
        e.preventDefault();
        return $(this).next().toggle();
      });
      return $("code.run").each(function() {
        var canvas, codeElement, compiledJs, source;
        codeElement = $(this);
        source = codeElement.text();
        compiledJs = CoffeeScript.compile(source, {
          bare: true
        });
        canvas = $("<canvas width=200 height=150/>").pixieCanvas();
        codeElement.after(canvas);
        return eval(compiledJs);
      });
    });
  //]]>
</script>
