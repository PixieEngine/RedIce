<!doctype html>
<html>
  <head>
    <meta charset='utf-8' />
    <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible' />
    <title>PixieCanvas</title>
    <link href='/assets/spacedocs/docs.css' media='screen, projection' rel='stylesheet' type='text/css' />
    <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js' type='text/javascript'></script>
  </head>
  <body>
    <pre></pre>
    <nav>
      <a href='Animated.html'>Animated</a>
      <a href='Array.html'>Array</a>
      <a href='Bindable.html'>Bindable</a>
      <a href='Boolean.html'>Boolean</a>
      <a href='Bounded.html'>Bounded</a>
      <a href='Camera.html'>Camera</a>
      <a href='Collidable.html'>Collidable</a>
      <a href='Collision.html'>Collision</a>
      <a href='Color.html'>Color</a>
      <a href='Core.html'>Core</a>
      <a href='Date.html'>Date</a>
      <a href='Drawable.html'>Drawable</a>
      <a href='Durable.html'>Durable</a>
      <a href='Engine.html'>Engine</a>
      <a href='Engine.Gamepads.html'>Engine.Gamepads</a>
      <a href='Engine.Joysticks.html'>Engine.Joysticks</a>
      <a href='Fadeable.html'>Fadeable</a>
      <a href='Flickerable.html'>Flickerable</a>
      <a href='Framerate.html'>Framerate</a>
      <a href='Function.html'>Function</a>
      <a href='GameObject.html'>GameObject</a>
      <a href='GameState.html'>GameState</a>
      <a href='Local.html'>Local</a>
      <a href='Math.html'>Math</a>
      <a href='Matrix.html'>Matrix</a>
      <a href='Movable.html'>Movable</a>
      <a href='Music.html'>Music</a>
      <a href='Number.html'>Number</a>
      <a href='Object.html'>Object</a>
      <a class='active' href='PixieCanvas.html'>PixieCanvas</a>
      <a href='Point.html'>Point</a>
      <a href='PowerCanvas.html'>PowerCanvas</a>
      <a href='Random.html'>Random</a>
      <a href='RegExp.html'>RegExp</a>
      <a href='ResourceLoader.html'>ResourceLoader</a>
      <a href='Rotatable.html'>Rotatable</a>
      <a href='Sound.html'>Sound</a>
      <a href='Sprite.html'>Sprite</a>
      <a href='String.html'>String</a>
      <a href='jQuery.html'>jQuery</a>
      <a href='justPressed.html'>justPressed</a>
      <a href='keydown.html'>keydown</a>
      <a href='requestAnimationFrame.html'>requestAnimationFrame</a>
      <a href='window.html'>window</a>
    </nav>
    <section class='method_list'>
      <h3>PixieCanvas Methods</h3>
      <div class='methods'>
        <a href='PixieCanvas.html##centerText'>#centerText</a>
        <a href='PixieCanvas.html##clear'>#clear</a>
        <a href='PixieCanvas.html##drawCircle'>#drawCircle</a>
        <a href='PixieCanvas.html##drawImage'>#drawImage</a>
        <a href='PixieCanvas.html##drawLine'>#drawLine</a>
        <a href='PixieCanvas.html##drawPoly'>#drawPoly</a>
        <a href='PixieCanvas.html##drawRect'>#drawRect</a>
        <a href='PixieCanvas.html##drawRoundRect'>#drawRoundRect</a>
        <a href='PixieCanvas.html##drawText'>#drawText</a>
        <a href='PixieCanvas.html##fill'>#fill</a>
        <a href='PixieCanvas.html##fillColor'>#fillColor</a>
        <a href='PixieCanvas.html##measureText'>#measureText</a>
        <a href='PixieCanvas.html##strokeColor'>#strokeColor</a>
        <a href='PixieCanvas.html##withTransform'>#withTransform</a>
      </div>
    </section>
    <div class='documentation'>
      <h1>PixieCanvas Summary</h1>
      <div class='description'>
        <section class='summary'></section>
        <p>PixieCanvas provides a convenient wrapper for working with Context2d.</p>
        <section class='usage'>
          <h3>Usage</h3>
          <p>Methods try to be as flexible as possible as to what arguments they take.</p>
          
          <p>Non-getter methods return <code>this</code> for method chaining.</p>
        </section>
      </div>
      <hr />
      <a name='#centerText'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#centerText(text, y, x, position, color)</h1>
      <div class='description'>
        <section class='summary'><p>Centers the given text on the canvas at the given y position. An x position<br />or point position can also be given in which case the text is centered at the<br />x, y or position value specified.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code class="run"><pre></p>&#x000A;&#x000A;<h1>Fill canvas to indicate bounds</h1>&#x000A;&#x000A;<p>canvas.fill<br />  color: "#eee"</p>&#x000A;&#x000A;<h1>A line to indicate the baseline</h1>&#x000A;&#x000A;<p>canvas.drawLine<br />  start: Point(25, 25)<br />  end: Point(125, 25)<br />  color: "#333"<br />  width: 1</p>&#x000A;&#x000A;<h1>Center text on the screen at y value 25</h1>&#x000A;&#x000A;<p>canvas.centerText<br />  y: 25<br />  color: "red"<br />  text: "It's dangerous to go alone"</p>&#x000A;&#x000A;<h1>Center text at point (75, 75)</h1>&#x000A;&#x000A;<p>canvas.centerText<br />  position: Point(75, 75)<br />  color: "green"<br />  text: "take this"</p>&#x000A;&#x000A;<p></pre></code></p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>text</span>
               -
              <span class='param_description'>Text to print</span>
            </li>
            <li>
              <span class='param_name'>y</span>
               -
              <span class='param_description'>location on the y axis to start printing</span>
            </li>
            <li>
              <span class='param_name'>x</span>
               -
              <span class='param_description'>location on the x axis to start printing. Overrides the default centering behavior if passed</span>
            </li>
            <li>
              <span class='param_name'>position</span>
               -
              <span class='param_description'>position to start printing. Overrides x and y if passed</span>
            </li>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color of text to print</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>centerText: function(_arg) {&#x000A;        var color, position, text, textWidth, x, y;&#x000A;        text = _arg.text, x = _arg.x, y = _arg.y, position = _arg.position, color = _arg.color;&#x000A;        if (position) x = position.x, y = position.y;&#x000A;        if (x == null) x = canvas.width / 2;&#x000A;        textWidth = this.measureText(text);&#x000A;        return this.drawText({&#x000A;          text: text,&#x000A;          color: color,&#x000A;          x: x - textWidth / 2,&#x000A;          y: y&#x000A;        });&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#clear'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#clear(x, y, width, height)</h1>
      <div class='description'>
        <section class='summary'><p>Clear the canvas (or a portion of it).</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p>Clear the entire canvas</p>&#x000A;&#x000A;<p><code><pre><br />canvas.clear()<br /></pre></code></p>&#x000A;&#x000A;<p>Clear a portion of the canvas</p>&#x000A;&#x000A;<p><code class="run"><pre></p>&#x000A;&#x000A;<h1>Set up: Fill canvas with blue</h1>&#x000A;&#x000A;<p>canvas.fill("blue")  </p>&#x000A;&#x000A;<h1>Clear a portion of the canvas</h1>&#x000A;&#x000A;<p>canvas.clear<br />  x: 50<br />  y: 50<br />  width: 50<br />  height: 50<br /></pre></code></p>&#x000A;&#x000A;<p>You can also clear the canvas by passing x, y, width height as<br />unnamed parameters:</p>&#x000A;&#x000A;<p><code><pre><br />canvas.clear(25, 25, 50, 50)<br /></pre></code></p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>x</span>
               -
              <span class='param_description'>where to start clearing on the x axis</span>
            </li>
            <li>
              <span class='param_name'>y</span>
               -
              <span class='param_description'>where to start clearing on the y axis</span>
            </li>
            <li>
              <span class='param_name'>width</span>
               -
              <span class='param_description'>width of area to clear</span>
            </li>
            <li>
              <span class='param_name'>height</span>
               -
              <span class='param_description'>height of area to clear</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>clear: function(x, y, width, height) {&#x000A;        var _ref;&#x000A;        if (x == null) x = {};&#x000A;        if (y == null) {&#x000A;          _ref = x, x = _ref.x, y = _ref.y, width = _ref.width, height = _ref.height;&#x000A;        }&#x000A;        x || (x = 0);&#x000A;        y || (y = 0);&#x000A;        if (width == null) width = canvas.width;&#x000A;        if (height == null) height = canvas.height;&#x000A;        context.clearRect(x, y, width, height);&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#drawCircle'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#drawCircle(x, y, position, radius, color, circle, stroke)</h1>
      <div class='description'>
        <section class='summary'><p>Draws a circle at the specified position with the specified<br />radius and color.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code class="run"><pre></p>&#x000A;&#x000A;<h1>Draw a large orange circle</h1>&#x000A;&#x000A;<p>canvas.drawCircle<br />  radius: 30<br />  position: Point(100, 75)<br />  color: "orange"</p>&#x000A;&#x000A;<h1>Draw a blue circle with radius 10 at (25, 50)</h1>&#x000A;&#x000A;<h1>and a red stroke</h1>&#x000A;&#x000A;<p>canvas.drawCircle<br />  x: 25<br />  y: 50<br />  radius: 10<br />  color: "blue"<br />  stroke:<br />    color: "red"<br />    width: 1</p>&#x000A;&#x000A;<h1>Create a circle object to set up the next examples</h1>&#x000A;&#x000A;<p>circle =<br />  radius: 20<br />  x: 50<br />  y: 50</p>&#x000A;&#x000A;<h1>Draw a given circle in yellow</h1>&#x000A;&#x000A;<p>canvas.drawCircle<br />  circle: circle<br />  color: "yellow"</p>&#x000A;&#x000A;<h1>Draw the circle in green at a different position</h1>&#x000A;&#x000A;<p>canvas.drawCircle<br />  circle: circle<br />  position: Point(25, 75)<br />  color: "green"</p>&#x000A;&#x000A;<h1>Draw an outline circle in purple.</h1>&#x000A;&#x000A;<p>canvas.drawCircle<br />  x: 50<br />  y: 75<br />  radius: 10<br />  stroke:<br />    color: "purple"<br />    width: 2<br /></pre></code></p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>x</span>
               -
              <span class='param_description'>location on the x axis to start drawing</span>
            </li>
            <li>
              <span class='param_name'>y</span>
               -
              <span class='param_description'>location on the y axis to start drawing</span>
            </li>
            <li>
              <span class='param_name'>position</span>
               -
              <span class='param_description'>position object of location to start drawing. This will override x and y values passed</span>
            </li>
            <li>
              <span class='param_name'>radius</span>
               -
              <span class='param_description'>length of the radius of the circle</span>
            </li>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color of the circle</span>
            </li>
            <li>
              <span class='param_name'>circle</span>
               -
              <span class='param_description'>circle object that contains position and radius. Overrides x, y, and radius if passed</span>
            </li>
            <li>
              <span class='param_name'>stroke</span>
               -
              <span class='param_description'>stroke object that specifies stroke color and stroke width</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>drawCircle: function(_arg) {&#x000A;        var circle, color, position, radius, stroke, x, y;&#x000A;        x = _arg.x, y = _arg.y, radius = _arg.radius, position = _arg.position, color = _arg.color, stroke = _arg.stroke, circle = _arg.circle;&#x000A;        if (circle) x = circle.x, y = circle.y, radius = circle.radius;&#x000A;        if (position) x = position.x, y = position.y;&#x000A;        context.beginPath();&#x000A;        context.arc(x, y, radius, 0, Math.TAU, true);&#x000A;        context.closePath();&#x000A;        if (color) {&#x000A;          this.fillColor(color);&#x000A;          context.fill();&#x000A;        }&#x000A;        if (stroke) {&#x000A;          this.strokeColor(stroke.color);&#x000A;          this.lineWidth(stroke.width);&#x000A;          context.stroke();&#x000A;        }&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#drawImage'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#drawImage(, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</h1>
      <div class='description'>
        <section class='summary'><p>A direct map to the Context2d draw image. <code>GameObject</code>s<br />that implement drawable will have this wrapped up nicely,<br />so there is a good chance that you will not have to deal with<br />it directly.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'></span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>sx</span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>sy</span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>sWidth</span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>sHeight</span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>dx</span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>dy</span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>dWidth</span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>dHeight</span>
               -
              <span class='param_description'></span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>drawImage: function(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {&#x000A;        context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#drawLine'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#drawLine(start, end, width, color)</h1>
      <div class='description'>
        <section class='summary'><p>Draw a line from <code>start</code> to <code>end</code>.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code class="run"><pre></p>&#x000A;&#x000A;<h1>Draw a sweet diagonal</h1>&#x000A;&#x000A;<p>canvas.drawLine<br />  start: Point(0, 0)<br />  end: Point(200, 200)<br />  color: "purple"</p>&#x000A;&#x000A;<h1>Draw another sweet diagonal</h1>&#x000A;&#x000A;<p>canvas.drawLine<br />  start: Point(200, 0)<br />  end: Point(0, 200)<br />  color: "red"<br />  width: 6</p>&#x000A;&#x000A;<h1>Now draw a sweet horizontal with a direction and a length</h1>&#x000A;&#x000A;<p>canvas.drawLine<br />  start: Point(0, 100)<br />  length: 200<br />  direction: Point(1, 0)<br />  color: "orange"</p>&#x000A;&#x000A;<p></pre></code></p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>start</span>
               -
              <span class='param_description'>position to start drawing from</span>
            </li>
            <li>
              <span class='param_name'>end</span>
               -
              <span class='param_description'>position to stop drawing</span>
            </li>
            <li>
              <span class='param_name'>width</span>
               -
              <span class='param_description'>width of the line</span>
            </li>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color of the line</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>drawLine: function(_arg) {&#x000A;        var color, direction, end, length, start, width;&#x000A;        start = _arg.start, end = _arg.end, width = _arg.width, color = _arg.color, direction = _arg.direction, length = _arg.length;&#x000A;        width || (width = 3);&#x000A;        if (direction) end = direction.norm(length).add(start);&#x000A;        this.lineWidth(width);&#x000A;        this.strokeColor(color);&#x000A;        context.beginPath();&#x000A;        context.moveTo(start.x, start.y);&#x000A;        context.lineTo(end.x, end.y);&#x000A;        context.closePath();&#x000A;        context.stroke();&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#drawPoly'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#drawPoly(points, color, stroke)</h1>
      <div class='description'>
        <section class='summary'><p>Draw a polygon.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code class="run"><pre></p>&#x000A;&#x000A;<h1>Draw a sweet rhombus</h1>&#x000A;&#x000A;<p>canvas.drawPoly<br />  points: [<br />    Point(50, 25)<br />    Point(75, 50)<br />    Point(50, 75)<br />    Point(25, 50)<br />  ]<br />  color: "purple"<br />  stroke:<br />    color: "red"<br />    width: 2<br /></pre></code></p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>points</span>
               -
              <span class='param_description'>collection of points that define the vertices of the polygon</span>
            </li>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color of the polygon</span>
            </li>
            <li>
              <span class='param_name'>stroke</span>
               -
              <span class='param_description'>stroke object that specifies stroke color and stroke width</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>drawPoly: function(_arg) {&#x000A;        var color, points, stroke;&#x000A;        points = _arg.points, color = _arg.color, stroke = _arg.stroke;&#x000A;        context.beginPath();&#x000A;        points.each(function(point, i) {&#x000A;          if (i === 0) {&#x000A;            return context.moveTo(point.x, point.y);&#x000A;          } else {&#x000A;            return context.lineTo(point.x, point.y);&#x000A;          }&#x000A;        });&#x000A;        context.lineTo(points[0].x, points[0].y);&#x000A;        if (color) {&#x000A;          this.fillColor(color);&#x000A;          context.fill();&#x000A;        }&#x000A;        if (stroke) {&#x000A;          this.strokeColor(stroke.color);&#x000A;          this.lineWidth(stroke.width);&#x000A;          context.stroke();&#x000A;        }&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#drawRect'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#drawRect(x, y, width, height, position, color, bounds, stroke)</h1>
      <div class='description'>
        <section class='summary'><p>Draws a rectangle at the specified position with given <br />width and height. Optionally takes a position, bounds<br />and color argument.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code class="run"><pre></p>&#x000A;&#x000A;<h1>Draw a red rectangle using x, y, width and height</h1>&#x000A;&#x000A;<p>canvas.drawRect<br />  x: 50<br />  y: 50<br />  width: 50<br />  height: 50<br />  color: "#F00"</p>&#x000A;&#x000A;<h1>Draw a blue rectangle using position, width and height</h1>&#x000A;&#x000A;<h1>and throw in a stroke for good measure</h1>&#x000A;&#x000A;<p>canvas.drawRect<br />  position: Point(0, 0)<br />  width: 50<br />  height: 50<br />  color: "blue"<br />  stroke:<br />    color: "orange"<br />    width: 3</p>&#x000A;&#x000A;<h1>Set up a bounds object for the next examples</h1>&#x000A;&#x000A;<p>bounds =<br />  x: 100<br />  y: 0<br />  width: 100<br />  height: 100</p>&#x000A;&#x000A;<h1>Draw a purple rectangle using bounds</h1>&#x000A;&#x000A;<p>canvas.drawRect<br />  bounds: bounds<br />  color: "green"</p>&#x000A;&#x000A;<h1>Draw the outline of the same bounds, but at a different position</h1>&#x000A;&#x000A;<p>canvas.drawRect<br />  bounds: bounds<br />  position: Point(0, 50)<br />  stroke:<br />    color: "purple"<br />    width: 2<br /></pre></code></p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>x</span>
               -
              <span class='param_description'>location on the x axis to start drawing</span>
            </li>
            <li>
              <span class='param_name'>y</span>
               -
              <span class='param_description'>location on the y axis to start drawing</span>
            </li>
            <li>
              <span class='param_name'>width</span>
               -
              <span class='param_description'>width of rectangle to draw</span>
            </li>
            <li>
              <span class='param_name'>height</span>
               -
              <span class='param_description'>height of rectangle to draw</span>
            </li>
            <li>
              <span class='param_name'>position</span>
               -
              <span class='param_description'>position to start drawing. Overrides x and y if passed</span>
            </li>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color of rectangle</span>
            </li>
            <li>
              <span class='param_name'>bounds</span>
               -
              <span class='param_description'>bounds of rectangle. Overrides x, y, width, height if passed</span>
            </li>
            <li>
              <span class='param_name'>stroke</span>
               -
              <span class='param_description'>stroke object that specifies stroke color and stroke width</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>drawRect: function(_arg) {&#x000A;        var bounds, color, height, position, stroke, width, x, y;&#x000A;        x = _arg.x, y = _arg.y, width = _arg.width, height = _arg.height, position = _arg.position, bounds = _arg.bounds, color = _arg.color, stroke = _arg.stroke;&#x000A;        if (bounds) {&#x000A;          x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height;&#x000A;        }&#x000A;        if (position) x = position.x, y = position.y;&#x000A;        if (color) {&#x000A;          this.fillColor(color);&#x000A;          context.fillRect(x, y, width, height);&#x000A;        }&#x000A;        if (stroke) {&#x000A;          this.strokeColor(stroke.color);&#x000A;          this.lineWidth(stroke.width);&#x000A;          context.strokeRect(x, y, width, height);&#x000A;        }&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#drawRoundRect'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#drawRoundRect(x, y, width, height, radius=5, position, color, bounds, stroke)</h1>
      <div class='description'>
        <section class='summary'><p>Draw a rounded rectangle.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p>Adapted from <a href='http://js-bits.blogspot.com/2010/07/canvas-rounded-corner-rectangles.html'>http://js-bits.blogspot.com/2010/07/canvas-rounded-corner-rectangles.html</a></p>&#x000A;&#x000A;<p><code class="run"><pre></p>&#x000A;&#x000A;<h1>Draw a purple rounded rectangle with a red outline</h1>&#x000A;&#x000A;<p>canvas.drawRoundRect<br />  position: Point(25, 25)<br />  radius: 10<br />  width: 150<br />  height: 100<br />  color: "purple"<br />  stroke:<br />    color: "red"<br />    width: 2<br /></pre></code></p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>x</span>
               -
              <span class='param_description'>location on the x axis to start drawing</span>
            </li>
            <li>
              <span class='param_name'>y</span>
               -
              <span class='param_description'>location on the y axis to start drawing</span>
            </li>
            <li>
              <span class='param_name'>width</span>
               -
              <span class='param_description'>width of the rounded rectangle</span>
            </li>
            <li>
              <span class='param_name'>height</span>
               -
              <span class='param_description'>height of the rounded rectangle</span>
            </li>
            <li>
              <span class='param_name'>radius=5</span>
               -
              <span class='param_description'>radius to round the rectangle corners</span>
            </li>
            <li>
              <span class='param_name'>position</span>
               -
              <span class='param_description'>position to start drawing. Overrides x and y if passed</span>
            </li>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color of the rounded rectangle</span>
            </li>
            <li>
              <span class='param_name'>bounds</span>
               -
              <span class='param_description'>bounds of the rounded rectangle. Overrides x, y, width, and height if passed</span>
            </li>
            <li>
              <span class='param_name'>stroke</span>
               -
              <span class='param_description'>stroke object that specifies stroke color and stroke width</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>drawRoundRect: function(_arg) {&#x000A;        var bounds, color, height, position, radius, stroke, width, x, y;&#x000A;        x = _arg.x, y = _arg.y, width = _arg.width, height = _arg.height, radius = _arg.radius, position = _arg.position, bounds = _arg.bounds, color = _arg.color, stroke = _arg.stroke;&#x000A;        if (radius == null) radius = 5;&#x000A;        if (bounds) {&#x000A;          x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height;&#x000A;        }&#x000A;        if (position) x = position.x, y = position.y;&#x000A;        context.beginPath();&#x000A;        context.moveTo(x + radius, y);&#x000A;        context.lineTo(x + width - radius, y);&#x000A;        context.quadraticCurveTo(x + width, y, x + width, y + radius);&#x000A;        context.lineTo(x + width, y + height - radius);&#x000A;        context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);&#x000A;        context.lineTo(x + radius, y + height);&#x000A;        context.quadraticCurveTo(x, y + height, x, y + height - radius);&#x000A;        context.lineTo(x, y + radius);&#x000A;        context.quadraticCurveTo(x, y, x + radius, y);&#x000A;        context.closePath();&#x000A;        if (color) {&#x000A;          this.fillColor(color);&#x000A;          context.fill();&#x000A;        }&#x000A;        if (stroke) {&#x000A;          this.lineWidth(stroke.width);&#x000A;          this.strokeColor(stroke.color);&#x000A;          context.stroke();&#x000A;        }&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#drawText'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#drawText(x, y, text, position, color)</h1>
      <div class='description'>
        <section class='summary'><p>Draws text on the canvas at the given position, in the given color.<br />If no color is given then the previous fill color is used.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code class="run"><pre></p>&#x000A;&#x000A;<h1>Fill canvas to indicate bounds</h1>&#x000A;&#x000A;<p>canvas.fill<br />  color: '#eee'</p>&#x000A;&#x000A;<h1>A line to indicate the baseline</h1>&#x000A;&#x000A;<p>canvas.drawLine<br />  start: Point(25, 50)<br />  end: Point(125, 50)<br />  color: "#333"<br />  width: 1</p>&#x000A;&#x000A;<h1>Draw some text, note the position of the baseline</h1>&#x000A;&#x000A;<p>canvas.drawText<br />  position: Point(25, 50)<br />  color: "red"<br />  text: "It's dangerous to go alone"</p>&#x000A;&#x000A;<p></pre></code></p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>x</span>
               -
              <span class='param_description'>location on x axis to start printing</span>
            </li>
            <li>
              <span class='param_name'>y</span>
               -
              <span class='param_description'>location on y axis to start printing</span>
            </li>
            <li>
              <span class='param_name'>text</span>
               -
              <span class='param_description'>text to print</span>
            </li>
            <li>
              <span class='param_name'>position</span>
               -
              <span class='param_description'>position to start printing. Overrides x and y if passed</span>
            </li>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color of text to start printing</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>drawText: function(_arg) {&#x000A;        var color, position, text, x, y;&#x000A;        x = _arg.x, y = _arg.y, text = _arg.text, position = _arg.position, color = _arg.color;&#x000A;        if (position) x = position.x, y = position.y;&#x000A;        this.fillColor(color);&#x000A;        context.fillText(text, x, y);&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#fill'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#fill(x=0, y=0, width=canvas.width, height=canvas.height, bounds, color)</h1>
      <div class='description'>
        <section class='summary'><p>Fills the entire canvas (or a specified section of it) with<br />the given color.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code class="run"><pre></p>&#x000A;&#x000A;<h1>Paint the town (entire canvas) red</h1>&#x000A;&#x000A;<p>canvas.fill "red"</p>&#x000A;&#x000A;<h1>Fill a section of the canvas white (#FFF)</h1>&#x000A;&#x000A;<p>canvas.fill<br />  x: 50<br />  y: 50<br />  width: 50<br />  height: 50<br />  color: "#FFF"<br /></pre></code></p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>x=0</span>
               -
              <span class='param_description'>Optional x position to fill from</span>
            </li>
            <li>
              <span class='param_name'>y=0</span>
               -
              <span class='param_description'>Optional y position to fill from</span>
            </li>
            <li>
              <span class='param_name'>width=canvas.width</span>
               -
              <span class='param_description'>Optional width of area to fill</span>
            </li>
            <li>
              <span class='param_name'>height=canvas.height</span>
               -
              <span class='param_description'>Optional height of area to fill</span>
            </li>
            <li>
              <span class='param_name'>bounds</span>
               -
              <span class='param_description'>bounds object to fill</span>
            </li>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color of area to fill</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>fill: function(color) {&#x000A;        var bounds, height, width, x, y, _ref;&#x000A;        if (color == null) color = {};&#x000A;        if (!((typeof color.isString === "function" ? color.isString() : void 0) || color.channels)) {&#x000A;          _ref = color, x = _ref.x, y = _ref.y, width = _ref.width, height = _ref.height, bounds = _ref.bounds, color = _ref.color;&#x000A;        }&#x000A;        if (bounds) {&#x000A;          x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height;&#x000A;        }&#x000A;        x || (x = 0);&#x000A;        y || (y = 0);&#x000A;        if (width == null) width = canvas.width;&#x000A;        if (height == null) height = canvas.height;&#x000A;        this.fillColor(color);&#x000A;        context.fillRect(x, y, width, height);&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#fillColor'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#fillColor(color)</h1>
      <div class='description'>
        <section class='summary'><p>A getter / setter method to set the canvas fillColor.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code><pre></p>&#x000A;&#x000A;<h1>Set the fill color</h1>&#x000A;&#x000A;<p>canvas.fillColor('#FF0000')</p>&#x000A;&#x000A;<h1>Passing no arguments returns the fillColor</h1>&#x000A;&#x000A;<p>canvas.fillColor()</p>&#x000A;&#x000A;<h1>=> '#FF0000'</h1>&#x000A;&#x000A;<h1>You can also pass a Color object</h1>&#x000A;&#x000A;<p>canvas.fillColor(Color('sky blue'))<br /></pre></code>      </p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color to make the canvas fillColor</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>fillColor: function(color) {&#x000A;        if (color) {&#x000A;          if (color.channels) {&#x000A;            context.fillStyle = color.toString();&#x000A;          } else {&#x000A;            context.fillStyle = color;&#x000A;          }&#x000A;          return this;&#x000A;        } else {&#x000A;          return context.fillStyle;&#x000A;        }&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#measureText'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#measureText(text)</h1>
      <div class='description'>
        <section class='summary'><p>Determine how wide some text is.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code><pre><br />canvas.measureText('Hello World!')</p>&#x000A;&#x000A;<h1>=> 55</h1>&#x000A;&#x000A;<p></pre></code>      </p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>text</span>
               -
              <span class='param_description'>the text to measure</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>measureText: function(text) {&#x000A;        return context.measureText(text).width;&#x000A;      },&#x000A;      putImageData: function(imageData, x, y) {&#x000A;        context.putImageData(imageData, x, y);&#x000A;        return this;&#x000A;      },&#x000A;      context: function() {&#x000A;        return context;&#x000A;      },&#x000A;      element: function() {&#x000A;        return canvas;&#x000A;      },&#x000A;      createPattern: function(image, repitition) {&#x000A;        return context.createPattern(image, repitition);&#x000A;      },&#x000A;      clip: function(x, y, width, height) {&#x000A;        context.beginPath();&#x000A;        context.rect(x, y, width, height);&#x000A;        context.clip();&#x000A;        return this;&#x000A;      }&#x000A;    });&#x000A;    contextAttrAccessor = function() {&#x000A;      var attrs;&#x000A;      attrs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];&#x000A;      return attrs.each(function(attr) {&#x000A;        return $canvas[attr] = function(newVal) {&#x000A;          if (newVal != null) {&#x000A;            context[attr] = newVal;&#x000A;            return this;&#x000A;          } else {&#x000A;            return context[attr];&#x000A;          }&#x000A;        };&#x000A;      });&#x000A;    };&#x000A;    canvasAttrAccessor = function() {&#x000A;      var attrs;&#x000A;      attrs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];&#x000A;      return attrs.each(function(attr) {&#x000A;        return $canvas[attr] = function(newVal) {&#x000A;          if (newVal != null) {&#x000A;            canvas[attr] = newVal;&#x000A;            return this;&#x000A;          } else {&#x000A;            return canvas[attr];&#x000A;          }&#x000A;        };&#x000A;      });&#x000A;    };&#x000A;    contextAttrAccessor("font", "globalAlpha", "globalCompositeOperation", "lineWidth", "textAlign");&#x000A;    canvasAttrAccessor("height", "width");&#x000A;    if (canvas != null ? canvas.getContext : void 0) {&#x000A;      context = canvas.getContext("2d");&#x000A;      if (options.init) options.init($canvas);&#x000A;      return $canvas;&#x000A;    }&#x000A;  };&#x000A;})(jQuery);&#x000A;&#x000A;var Player;&#x000A;&#x000A;Player = function(I) {&#x000A;  var actionDown, addSprayParticleEffect, axisPosition, controller, forceFacing, jitterSoak, particleSizes, self, setFacing, setFlip, shootPuck;&#x000A;  $.reverseMerge(I, {&#x000A;    blood: {&#x000A;      face: 0,&#x000A;      body: 0,&#x000A;      leftSkate: 0,&#x000A;      rightSkate: 0&#x000A;    },&#x000A;    boost: 0,&#x000A;    boostMeter: 64,&#x000A;    cooldown: {&#x000A;      boost: 0,&#x000A;      facing: 0,&#x000A;      flip: 0,&#x000A;      shoot: 0&#x000A;    },&#x000A;    collisionMargin: Point(2, 2),&#x000A;    controller: 0,&#x000A;    controlRadius: 30,&#x000A;    falls: 0,&#x000A;    friction: 0.1,&#x000A;    heading: 0,&#x000A;    joystick: true,&#x000A;    maxShotPower: 20,&#x000A;    movementDirection: 0,&#x000A;    movementSpeed: 1.25,&#x000A;    radius: 20,&#x000A;    width: 32,&#x000A;    height: 32,&#x000A;    x: 192,&#x000A;    y: 128,&#x000A;    slot: 0,&#x000A;    shootPower: 0,&#x000A;    shootHoldFrame: 5,&#x000A;    team: 0,&#x000A;    headStyle: "stubs",&#x000A;    teamStyle: "spike",&#x000A;    bodyStyle: "tubs",&#x000A;    wipeout: 0,&#x000A;    velocity: Point(),&#x000A;    zIndex: 1&#x000A;  });&#x000A;  if (I.joystick) {&#x000A;    controller = engine.controller(I.id);&#x000A;    actionDown = controller.actionDown;&#x000A;    axisPosition = controller.axis;&#x000A;  } else {&#x000A;    actionDown = CONTROLLERS[I.controller].actionDown;&#x000A;    axisPosition = $.noop;&#x000A;  }&#x000A;  particleSizes = [5, 4, 3];&#x000A;  addSprayParticleEffect = function(push, color) {&#x000A;    if (color == null) color = BLOOD_COLOR;&#x000A;    if (!config.particleEffects) return;&#x000A;    push = push.norm(13);&#x000A;    return engine.add({&#x000A;      "class": "Emitter",&#x000A;      duration: 9,&#x000A;      sprite: Sprite.EMPTY,&#x000A;      velocity: I.velocity,&#x000A;      particleCount: 5,&#x000A;      batchSize: 5,&#x000A;      x: I.x + I.width / 2 + push.x,&#x000A;      y: I.y + I.height / 2 + push.y,&#x000A;      zIndex: 1 + (I.y + I.height + 1) / CANVAS_HEIGHT,&#x000A;      generator: {&#x000A;        color: color,&#x000A;        duration: 8,&#x000A;        height: function(n) {&#x000A;          return particleSizes.wrap(n);&#x000A;        },&#x000A;        maxSpeed: 50,&#x000A;        velocity: function(n) {&#x000A;          return Point.fromAngle(Random.angle()).scale(rand(5) + 1).add(push);&#x000A;        },&#x000A;        width: function(n) {&#x000A;          return particleSizes.wrap(n);&#x000A;        }&#x000A;      }&#x000A;    });&#x000A;  };&#x000A;  jitterSoak = 10;&#x000A;  setFacing = function(newFacing) {&#x000A;    if (!I.cooldown.facing) {&#x000A;      I.cooldown.facing = jitterSoak;&#x000A;      return I.facing = newFacing;&#x000A;    }&#x000A;  };&#x000A;  forceFacing = function(newFacing) {&#x000A;    I.facing = newFacing;&#x000A;    return I.cooldown.facing = jitterSoak;&#x000A;  };&#x000A;  setFlip = function(newFlip) {&#x000A;    if (I.hflip !== newFlip) {&#x000A;      if (!I.cooldown.flip) {&#x000A;        I.cooldown.flip = jitterSoak;&#x000A;        return I.hflip = newFlip;&#x000A;      }&#x000A;    }&#x000A;  };&#x000A;  self = Base(I).extend({&#x000A;    bloody: function() {&#x000A;      if (I.wipeout) {&#x000A;        return I.blood.body += rand(5);&#x000A;      } else {&#x000A;        I.blood.leftSkate = (I.blood.leftSkate + rand(10)).clamp(0, 60);&#x000A;        return I.blood.rightSkate = (I.blood.rightSkate + rand(10)).clamp(0, 60);&#x000A;      }&#x000A;    },&#x000A;    color: function() {&#x000A;      if (I.cpu) {&#x000A;        return Color(Player.CPU_COLOR);&#x000A;      } else {&#x000A;        return Color(Player.COLORS[I.team]).lighten((I.slot - 1) * 0.1);&#x000A;      }&#x000A;    },&#x000A;    controlCircle: function() {&#x000A;      var c, p, speed;&#x000A;      p = Point.fromAngle(I.heading).scale(I.controlRadius);&#x000A;      c = self.center().add(p);&#x000A;      speed = I.velocity.magnitude();&#x000A;      c.radius = I.controlRadius + ((100 - speed * speed) / 100 * 8).clamp(-7, 8);&#x000A;      return c;&#x000A;    },&#x000A;    controlPuck: function(puck) {&#x000A;      var maxPuckForce, p, positionDelta, puckControl, puckVelocity, targetPuckPosition;&#x000A;      if (I.cooldown.shoot) return;&#x000A;      puckControl = 0.04;&#x000A;      maxPuckForce = puckControl / puck.mass();&#x000A;      p = Point.fromAngle(I.heading).scale(48);&#x000A;      targetPuckPosition = self.center().add(p);&#x000A;      puckVelocity = puck.I.velocity;&#x000A;      positionDelta = targetPuckPosition.subtract(puck.center().add(puckVelocity));&#x000A;      if (positionDelta.magnitude() > maxPuckForce) {&#x000A;        positionDelta = positionDelta.norm().scale(maxPuckForce);&#x000A;      }&#x000A;      I.hasPuck = true;&#x000A;      return puck.I.velocity = puck.I.velocity.add(positionDelta);&#x000A;    },&#x000A;    wipeout: function(push) {&#x000A;      I.falls += 1;&#x000A;      I.wipeout = 25;&#x000A;      I.blood.face += rand(20) + rand(20) + rand(20) + I.falls;&#x000A;      I.shootPower = 0;&#x000A;      push = push.norm().scale(30);&#x000A;      Sound.play("hit" + (rand(4)));&#x000A;      Sound.play("crowd" + (rand(3)));&#x000A;      addSprayParticleEffect(push);&#x000A;      return engine.add({&#x000A;        "class": "Blood",&#x000A;        x: I.x + push.x,&#x000A;        y: I.y + push.y&#x000A;      });&#x000A;    }&#x000A;  });&#x000A;  shootPuck = function(direction) {&#x000A;    var baseShotPower, circle, hit, p, power, puck;&#x000A;    puck = engine.find("Puck").first();&#x000A;    power = Math.min(I.shootPower, I.maxShotPower);&#x000A;    circle = self.controlCircle();&#x000A;    circle.radius *= 2;&#x000A;    baseShotPower = 15;&#x000A;    if (puck && Collision.circular(circle, puck.circle())) {&#x000A;      if (I.shootPower >= 2 * I.maxShotPower) puck.trigger("superCharge");&#x000A;      p = Point.fromAngle(direction).scale(baseShotPower + power * 2);&#x000A;      puck.I.velocity = puck.I.velocity.add(p);&#x000A;    } else {&#x000A;      hit = false;&#x000A;      engine.find("Player").without([self]).each(function(player) {&#x000A;        if (hit) return;&#x000A;        if (Collision.circular(circle, player.circle())) {&#x000A;          hit = true;&#x000A;          p = Point.fromAngle(direction).scale(power);&#x000A;          if (power > 10) player.wipeout(p);&#x000A;          return player.I.velocity = player.I.velocity.add(p);&#x000A;        }&#x000A;      });&#x000A;    }&#x000A;    return I.shootPower = 0;&#x000A;  };&#x000A;  self.bind("step", function() {&#x000A;    var key, value, _ref, _results;&#x000A;    _ref = I.cooldown;&#x000A;    _results = [];&#x000A;    for (key in _ref) {&#x000A;      value = _ref[key];&#x000A;      _results.push(I.cooldown[key] = value.approach(0, 1));&#x000A;    }&#x000A;    return _results;&#x000A;  });&#x000A;  self.bind("step", function() {&#x000A;    var bonus, movement, movementLength, movementScale, velocityLength, velocityNorm;&#x000A;    I.boost = I.boost.approach(0, 1);&#x000A;    I.wipeout = I.wipeout.approach(0, 1);&#x000A;    if (I.velocity.magnitude() !== 0) {&#x000A;      I.heading = Point.direction(Point(0, 0), I.velocity);&#x000A;    }&#x000A;    self.drawBloodStreaks();&#x000A;    movementScale = I.movementSpeed;&#x000A;    movement = Point(0, 0);&#x000A;    if (I.cpu) {&#x000A;      movement = self.computeDirection();&#x000A;      if (controller != null ? controller.actionDown("START") : void 0) {&#x000A;        I.cpu = false;&#x000A;      }&#x000A;    } else if (controller) {&#x000A;      movement = controller.position();&#x000A;    } else {&#x000A;      if (actionDown("left")) movement = movement.add(Point(-1, 0));&#x000A;      if (actionDown("right")) movement = movement.add(Point(1, 0));&#x000A;      if (actionDown("up")) movement = movement.add(Point(0, -1));&#x000A;      if (actionDown("down")) movement = movement.add(Point(0, 1));&#x000A;      movement = movement.norm();&#x000A;    }&#x000A;    if (movement.x || movement.y) I.movementDirection = movement.direction();&#x000A;    if (actionDown("BACK")) self.wipeout(Point(1, 0));&#x000A;    if (I.wipeout) {&#x000A;      I.lastLeftSkatePos = null;&#x000A;      return I.lastRightSkatePos = null;&#x000A;    } else {&#x000A;      if (!I.cooldown.shoot && actionDown("B", "X")) {&#x000A;        if (I.shootPower < I.maxShotPower) {&#x000A;          I.shootPower += 1;&#x000A;        } else {&#x000A;          I.shootPower += 2;&#x000A;        }&#x000A;        movementScale = 0.1;&#x000A;      } else if (I.cooldown.shoot) {&#x000A;        if (I.cooldown.shoot === I.shootCooldownFrameCount - 2) {&#x000A;          shootPuck(I.movementDirection);&#x000A;        }&#x000A;      } else if (I.shootPower) {&#x000A;        I.cooldown.shoot = I.shootCooldownFrameCount;&#x000A;      } else if (I.cooldown.boost < I.boostMeter && (actionDown("A", "L", "R") || (axisPosition(4) > 0) || (axisPosition(5) > 0))) {&#x000A;        if (I.cooldown.boost === 0) {&#x000A;          bonus = 10;&#x000A;        } else {&#x000A;          bonus = 2;&#x000A;        }&#x000A;        I.cooldown.boost += 4;&#x000A;        movement = movement.scale(bonus);&#x000A;      }&#x000A;      velocityNorm = I.velocity.norm();&#x000A;      velocityLength = I.velocity.length();&#x000A;      movementLength = movement.length();&#x000A;      if ((velocityLength > 4) && (movement.dot(velocityNorm) < (-0.95) * movementLength)) {&#x000A;        addSprayParticleEffect(I.velocity, "rgba(128, 202, 255, 1)");&#x000A;        I.velocity.x = 0;&#x000A;        I.velocity.y = 0;&#x000A;      } else {&#x000A;        movement = movement.scale(movementScale);&#x000A;        I.velocity = I.velocity.add(movement);&#x000A;      }&#x000A;      return I.hasPuck = false;&#x000A;    }&#x000A;  });&#x000A;  self.bind("update", function() {&#x000A;    var angleSprites, cycleDelay, headDirection, headIndexOffset, headPosition, power, speed, spriteSheet, _ref;&#x000A;    Object.extend(I, teamSprites[I.teamStyle][I.bodyStyle].characterData);&#x000A;    I.headAction = "normal";&#x000A;    setFlip(I.heading > 2 * Math.TAU / 8 || I.heading < -2 * Math.TAU / 8);&#x000A;    spriteSheet = self.spriteSheet();&#x000A;    speed = I.velocity.magnitude();&#x000A;    cycleDelay = 16;&#x000A;    if ((0 <= (_ref = I.heading) && _ref <= Math.TAU / 2)) {&#x000A;      setFacing("front");&#x000A;    } else {&#x000A;      setFacing("back");&#x000A;    }&#x000A;    if (speed < 1) {&#x000A;      I.action = "idle";&#x000A;    } else if (speed < 6) {&#x000A;      I.action = "slow";&#x000A;      cycleDelay = 4;&#x000A;    } else {&#x000A;      I.action = "fast";&#x000A;      cycleDelay = 3;&#x000A;    }&#x000A;    if (I.wipeout) {&#x000A;      forceFacing("front");&#x000A;      I.action = "fall";&#x000A;      I.headAction = "pain";&#x000A;      I.frame = ((25 - I.wipeout) / 3).floor().clamp(0, 5);&#x000A;    } else if (power = I.shootPower) {&#x000A;      forceFacing("front");&#x000A;      I.action = "shoot";&#x000A;      if (power < I.maxShotPower) {&#x000A;        I.frame = ((power * I.shootHoldFrame + 1) / I.maxShotPower).floor();&#x000A;      } else {&#x000A;        I.headAction = "charged";&#x000A;        I.frame = I.shootHoldFrame + (I.age / 6).floor() % 2;&#x000A;      }&#x000A;    } else if (I.cooldown.shoot) {&#x000A;      I.action = "shoot";&#x000A;      setFacing("front");&#x000A;      I.frame = 10 - I.cooldown.shoot;&#x000A;    } else {&#x000A;      I.frame = (I.age / cycleDelay).floor();&#x000A;    }&#x000A;    if (I.facing === "front") {&#x000A;      headDirection = I.heading.constrainRotation();&#x000A;      if (headDirection < -Math.TAU / 4) {&#x000A;        headDirection = Math.TAU / 2;&#x000A;      } else if (headDirection < 0) {&#x000A;        headDirection = 0;&#x000A;      }&#x000A;    } else {&#x000A;      headDirection = I.heading;&#x000A;    }&#x000A;    angleSprites = 8;&#x000A;    headIndexOffset = 2;&#x000A;    headPosition = ((angleSprites * -headDirection / Math.TAU).round() + headIndexOffset).mod(angleSprites);&#x000A;    if (headPosition >= 5) {&#x000A;      headPosition = 8 - headPosition;&#x000A;      I.headFlip = true;&#x000A;    } else {&#x000A;      I.headFlip = false;&#x000A;    }&#x000A;    return I.headSprite = teamSprites[I.teamStyle][I.headStyle][I.headAction][headPosition];&#x000A;  });&#x000A;  if (I.cpu) self.include(AI);&#x000A;  self.include(PlayerState);&#x000A;  self.include(PlayerDrawing);&#x000A;  return self;&#x000A;};&#x000A;&#x000A;Player.COLORS = ["#0246E3", "#EB070E", "#388326", "#F69508", "#563495", "#58C4F5", "#FFDE49"];&#x000A;&#x000A;Player.CPU_COLOR = "#888";&#x000A;&#x000A;var PlayerDrawing;&#x000A;&#x000A;PlayerDrawing = function(I, self) {&#x000A;  var assetScale, drawBody;&#x000A;  Object.reverseMerge(I, {&#x000A;    scale: 1&#x000A;  });&#x000A;  assetScale = 0.5;&#x000A;  drawBody = function(canvas) {&#x000A;    var sprite;&#x000A;    if (sprite = I.sprite) {&#x000A;      return sprite.draw(canvas, -sprite.width / 2, -sprite.height / 2);&#x000A;    }&#x000A;  };&#x000A;  self.unbind('draw');&#x000A;  self.bind('draw', function(canvas) {&#x000A;    var currentHeadOffset, drawHead, frameData, headOffset, headRotation, headScale, t;&#x000A;    if (frameData = self.frameData()) {&#x000A;      headOffset = Point(frameData.head.x, frameData.head.y);&#x000A;      headRotation = frameData.head.rotation;&#x000A;      headScale = frameData.head.scale;&#x000A;    } else {&#x000A;      headOffset = Point(32, -64).add(Point(3 * Math.sin(I.age * Math.TAU / 31), 2 * Math.cos(I.age * Math.TAU / 27)));&#x000A;      headRotation = 0;&#x000A;      headScale = 0.75;&#x000A;    }&#x000A;    drawHead = function(canvas) {&#x000A;      return canvas.withTransform(Matrix.translation(currentHeadOffset.x, currentHeadOffset.y), function(canvas) {&#x000A;        var headSprite;&#x000A;        if (headSprite = I.headSprite) {&#x000A;          return canvas.withTransform(Matrix.scale(headScale).rotate(headRotation), function(canvas) {&#x000A;            if (I.headFlip) {&#x000A;              return canvas.withTransform(Matrix.HORIZONTAL_FLIP, function(canvas) {&#x000A;                return headSprite.draw(canvas, -headSprite.width / 2, -headSprite.height / 2);&#x000A;              });&#x000A;            } else {&#x000A;              return headSprite.draw(canvas, -headSprite.width / 2, -headSprite.height / 2);&#x000A;            }&#x000A;          });&#x000A;        }&#x000A;      });&#x000A;    };&#x000A;    t = Matrix.IDENTITY;&#x000A;    if (I.hflip) {&#x000A;      t = Matrix.HORIZONTAL_FLIP;&#x000A;      headRotation = -headRotation;&#x000A;    }&#x000A;    currentHeadOffset = t.transformPoint(headOffset.scale(assetScale));&#x000A;    return canvas.withTransform(Matrix.translation(0, -32), function() {&#x000A;      if (I.facing === "back") drawHead(canvas);&#x000A;      canvas.withTransform(t, drawBody);&#x000A;      if (I.facing === "front") return drawHead(canvas);&#x000A;    });&#x000A;  });&#x000A;  self.bind('drawDebug', function(canvas) {&#x000A;    var x, y, _ref;&#x000A;    if (I.AI_TARGET) {&#x000A;      _ref = I.AI_TARGET, x = _ref.x, y = _ref.y;&#x000A;      canvas.drawCircle({&#x000A;        x: x,&#x000A;        y: y,&#x000A;        radius: 3,&#x000A;        color: "rgba(255, 255, 0, 1)"&#x000A;      });&#x000A;    }&#x000A;    return self.drawControlCircle(canvas);&#x000A;  });&#x000A;  self.bind('afterTransform', function(canvas) {&#x000A;    self.drawPowerMeters(canvas);&#x000A;    return self.drawFloatingNameTag(canvas);&#x000A;  });&#x000A;  I.lastLeftSkatePos = null;&#x000A;  I.lastRightSkatePos = null;&#x000A;  return {&#x000A;    leftSkatePos: function() {&#x000A;      var p;&#x000A;      p = Point.fromAngle(I.heading - Math.TAU / 4).scale(5);&#x000A;      return self.center().add(p);&#x000A;    },&#x000A;    rightSkatePos: function() {&#x000A;      var p;&#x000A;      p = Point.fromAngle(I.heading + Math.TAU / 4).scale(5);&#x000A;      return self.center().add(p);&#x000A;    },&#x000A;    drawBloodStreaks: function() {&#x000A;      var blood, color, currentLeftSkatePos, currentPos, currentRightSkatePos, cycle, skateBlood, thickness;&#x000A;      if ((blood = I.blood.face) && rand(2) === 0) {&#x000A;        color = Color(BLOOD_COLOR);&#x000A;        currentPos = self.center();&#x000A;        (rand(blood) / 3).floor().clamp(0, 2).times(function() {&#x000A;          var p;&#x000A;          I.blood.face -= 1;&#x000A;          p = currentPos.add(Point.fromAngle(Random.angle()).scale(rand() * rand() * 16));&#x000A;          return bloodCanvas.drawCircle({&#x000A;            position: p,&#x000A;            radius: (rand(5) * rand() * rand()).clamp(0, 3),&#x000A;            color: color&#x000A;          });&#x000A;        });&#x000A;      }&#x000A;      if (I.wipeout) {} else {&#x000A;        currentLeftSkatePos = self.leftSkatePos();&#x000A;        currentRightSkatePos = self.rightSkatePos();&#x000A;        cycle = I.age % 30;&#x000A;        if ((1 < cycle && cycle < 14)) I.lastLeftSkatePos = null;&#x000A;        if ((15 < cycle && cycle < 29)) I.lastRightSkatePos = null;&#x000A;        if (I.lastLeftSkatePos) {&#x000A;          if (skateBlood = I.blood.leftSkate) {&#x000A;            I.blood.leftSkate -= 1;&#x000A;            color = BLOOD_COLOR;&#x000A;            thickness = (skateBlood / 30).clamp(0, 1.5);&#x000A;          } else {&#x000A;            color = ICE_COLOR;&#x000A;            thickness = 1;&#x000A;          }&#x000A;          bloodCanvas.drawLine({&#x000A;            start: I.lastLeftSkatePos,&#x000A;            end: currentLeftSkatePos,&#x000A;            width: thickness,&#x000A;            color: color&#x000A;          });&#x000A;        }&#x000A;        if (I.lastRightSkatePos) {&#x000A;          if (skateBlood = I.blood.rightSkate) {&#x000A;            I.blood.rightSkate -= 1;&#x000A;            color = BLOOD_COLOR;&#x000A;            thickness = (skateBlood / 30).clamp(0, 1.5);&#x000A;          } else {&#x000A;            color = ICE_COLOR;&#x000A;            thickness = 1;&#x000A;          }&#x000A;          bloodCanvas.strokeColor(color);&#x000A;          bloodCanvas.drawLine({&#x000A;            start: I.lastRightSkatePos,&#x000A;            end: currentRightSkatePos,&#x000A;            width: thickness,&#x000A;            color: color&#x000A;          });&#x000A;        }&#x000A;        I.lastLeftSkatePos = currentLeftSkatePos;&#x000A;        return I.lastRightSkatePos = currentRightSkatePos;&#x000A;      }&#x000A;    },&#x000A;    drawShadow: function(canvas) {&#x000A;      var base;&#x000A;      base = self.center().add(0, I.height / 2 + 4);&#x000A;      return canvas.withTransform(Matrix.scale(1, -0.5, base), function() {&#x000A;        var shadowColor, x, y, _i, _len, _ref, _ref2, _results;&#x000A;        shadowColor = "rgba(0, 0, 0, 0.15)";&#x000A;        _ref = [[-4, 16], [0, 8], [4, 16]];&#x000A;        _results = [];&#x000A;        for (_i = 0, _len = _ref.length; _i < _len; _i++) {&#x000A;          _ref2 = _ref[_i], x = _ref2[0], y = _ref2[1];&#x000A;          _results.push(canvas.drawCircle({&#x000A;            x: base.x + x,&#x000A;            y: base.y + y,&#x000A;            radius: 16,&#x000A;            color: shadowColor&#x000A;          }));&#x000A;        }&#x000A;        return _results;&#x000A;      });&#x000A;    },&#x000A;    drawFloatingNameTag: function(canvas) {&#x000A;      var backgroundColor, center, lineHeight, name, padding, rectHeight, rectWidth, textWidth, topLeft, yOffset;&#x000A;      canvas.font("bold 16px consolas, 'Courier New', 'andale mono', 'lucida console', monospace");&#x000A;      if (I.cpu) {&#x000A;        name = "CPU";&#x000A;      } else {&#x000A;        name = I.name || ("P" + (I.id + 1));&#x000A;      }&#x000A;      padding = 6;&#x000A;      lineHeight = 16;&#x000A;      textWidth = canvas.measureText(name);&#x000A;      backgroundColor = self.color();&#x000A;      backgroundColor.a = 0.5;&#x000A;      yOffset = 80;&#x000A;      center = self.center();&#x000A;      topLeft = center.subtract(Point(textWidth / 2 + padding, lineHeight / 2 + padding + yOffset));&#x000A;      rectWidth = textWidth + 2 * padding;&#x000A;      rectHeight = lineHeight + 2 * padding;&#x000A;      canvas.drawRoundRect({&#x000A;        color: backgroundColor,&#x000A;        position: topLeft,&#x000A;        width: rectWidth,&#x000A;        height: rectHeight,&#x000A;        radius: 4&#x000A;      });&#x000A;      return canvas.drawText({&#x000A;        text: name,&#x000A;        color: "#FFF",&#x000A;        x: topLeft.x + padding,&#x000A;        y: topLeft.y + lineHeight + padding / 2&#x000A;      });&#x000A;    },&#x000A;    drawTurboMeter: function(canvas) {&#x000A;      var center, color, height, maxWidth, padding, ratio, start;&#x000A;      ratio = (I.boostMeter - I.cooldown.boost) / I.boostMeter;&#x000A;      padding = 1.25;&#x000A;      maxWidth = 48;&#x000A;      height = 4;&#x000A;      center = self.center();&#x000A;      start = center.add(Point(-maxWidth / 2, 24));&#x000A;      canvas.drawRoundRect({&#x000A;        color: "#000",&#x000A;        x: start.x - padding,&#x000A;        y: start.y - padding,&#x000A;        width: maxWidth + 2 * padding,&#x000A;        height: height + 2 * padding,&#x000A;        radius: 2&#x000A;      });&#x000A;      if (I.cooldown.boost === 0) {&#x000A;        color = "#0F0";&#x000A;      } else {&#x000A;        color = "#080";&#x000A;      }&#x000A;      return canvas.drawRoundRect({&#x000A;        color: color,&#x000A;        position: start,&#x000A;        width: maxWidth * ratio,&#x000A;        height: height,&#x000A;        radius: 2&#x000A;      });&#x000A;    },&#x000A;    drawShootMeter: function(canvas) {&#x000A;      var arrowAnimation, center, ratio, superChargeRatio;&#x000A;      if (I.shootPower) {&#x000A;        ratio = Math.min(I.shootPower / I.maxShotPower, 1);&#x000A;        superChargeRatio = ((I.shootPower - I.maxShotPower) / I.maxShotPower).clamp(0, 1);&#x000A;        center = self.center().floor();&#x000A;        arrowAnimation = PlayerDrawing.shootArrow;&#x000A;        if (superChargeRatio === 1) {&#x000A;          arrowAnimation = PlayerDrawing.chargedArrow;&#x000A;          canvas.withTransform(Matrix.translation(center.x - 5, center.y - 40).scale(0.375), function(canvas) {&#x000A;            var _ref;&#x000A;            return (_ref = PlayerDrawing.chargeAura.rand()) != null ? _ref.draw(canvas, -256, -256) : void 0;&#x000A;          });&#x000A;        }&#x000A;        return canvas.withTransform(Matrix.translation(center.x, center.y).concat(Matrix.scale(0.125 + ratio * 0.375)).concat(Matrix.rotation(I.movementDirection)), function(canvas) {&#x000A;          return arrowAnimation.wrap((I.age / 4).floor()).draw(canvas, -256, -256);&#x000A;        });&#x000A;      }&#x000A;    },&#x000A;    drawPowerMeters: function(canvas) {&#x000A;      self.drawTurboMeter(canvas);&#x000A;      return self.drawShootMeter(canvas);&#x000A;    },&#x000A;    drawControlCircle: function(canvas) {&#x000A;      var circle, color;&#x000A;      color = self.color().lighten(0.10);&#x000A;      color.a = 0.25;&#x000A;      circle = self.controlCircle();&#x000A;      return canvas.drawCircle({&#x000A;        circle: circle,&#x000A;        color: color&#x000A;      });&#x000A;    },&#x000A;    transform: function() {&#x000A;      var center, transform;&#x000A;      center = self.center();&#x000A;      transform = Matrix.translation(center.x, center.y);&#x000A;      if (I.rotation) transform = transform.concat(Matrix.rotation(I.rotation));&#x000A;      transform = transform.concat(Matrix.scale(I.scale));&#x000A;      if (I.spriteOffset) {&#x000A;        transform = transform.concat(Matrix.translation(I.spriteOffset.x, I.spriteOffset.y));&#x000A;      }&#x000A;      return transform;&#x000A;    }&#x000A;  };&#x000A;};&#x000A;&#x000A;PlayerDrawing.shootArrow = Sprite.loadSheet("arrow_3", 512, 512);&#x000A;&#x000A;PlayerDrawing.chargedArrow = Sprite.loadSheet("arrow_charged_3", 512, 512);&#x000A;&#x000A;PlayerDrawing.chargeAura = Sprite.loadSheet("charge_aura_strip2", 512, 512);&#x000A;&#x000A;var PlayerState;&#x000A;&#x000A;PlayerState = function(I, self) {&#x000A;  if (I == null) I = {};&#x000A;  Object.reverseMerge(I, {&#x000A;    frame: 0,&#x000A;    action: "idle",&#x000A;    facing: "front"&#x000A;  });&#x000A;  self.bind("update", function() {&#x000A;    return I.sprite = self.spriteSheet()[I.action][I.facing].wrap(I.frame);&#x000A;  });&#x000A;  return {&#x000A;    spriteSheet: function() {&#x000A;      return teamSprites[I.teamStyle][I.bodyStyle];&#x000A;    },&#x000A;    frameData: function() {&#x000A;      var _ref, _ref2;&#x000A;      return (_ref = self.spriteSheet().data[I.action]) != null ? (_ref2 = _ref[I.facing]) != null ? _ref2.wrap(I.frame) : void 0 : void 0;&#x000A;    }&#x000A;  };&#x000A;};&#x000A;&#x000A;var Puck;&#x000A;&#x000A;Puck = function(I) {&#x000A;  var DEBUG_DRAW, DEFAULT_FRICTION, addParticleEffect, drawBloodStreaks, heading, lastPosition, particleSizes, self;&#x000A;  DEBUG_DRAW = false;&#x000A;  DEFAULT_FRICTION = 0.05;&#x000A;  $.reverseMerge(I, {&#x000A;    blood: 0,&#x000A;    color: "black",&#x000A;    strength: 0.5,&#x000A;    radius: 8,&#x000A;    width: 16,&#x000A;    height: 8,&#x000A;    x: 512 - 8,&#x000A;    y: (WALL_BOTTOM + WALL_TOP) / 2 - 4,&#x000A;    friction: DEFAULT_FRICTION,&#x000A;    mass: 0.01,&#x000A;    superMassive: false,&#x000A;    zIndex: 10,&#x000A;    spriteOffset: Point(-2, -12)&#x000A;  });&#x000A;  self = Base(I).extend({&#x000A;    bloody: function() {&#x000A;      return I.blood = (I.blood + 30).clamp(0, 120);&#x000A;    },&#x000A;    wipeout: $.noop&#x000A;  });&#x000A;  heading = 0;&#x000A;  lastPosition = null;&#x000A;  particleSizes = [3, 4, 3];&#x000A;  addParticleEffect = function(push, color) {&#x000A;    if (color == null) color = "#EE0";&#x000A;    push = push.norm(4);&#x000A;    return engine.add({&#x000A;      "class": "Emitter",&#x000A;      duration: 9,&#x000A;      sprite: Sprite.EMPTY,&#x000A;      velocity: I.velocity,&#x000A;      particleCount: 3,&#x000A;      batchSize: 3,&#x000A;      x: I.x + I.width / 2,&#x000A;      y: I.y + I.height / 2,&#x000A;      zIndex: 1 + (I.y + I.height + 1) / CANVAS_HEIGHT,&#x000A;      generator: {&#x000A;        color: color,&#x000A;        duration: 8,&#x000A;        height: function(n) {&#x000A;          return particleSizes.wrap(n);&#x000A;        },&#x000A;        maxSpeed: 50,&#x000A;        velocity: function(n) {&#x000A;          return Point.fromAngle(Random.angle()).scale(rand(5) + 1).add(push);&#x000A;        },&#x000A;        width: function(n) {&#x000A;          return particleSizes.wrap(n);&#x000A;        }&#x000A;      }&#x000A;    });&#x000A;  };&#x000A;  drawBloodStreaks = function() {&#x000A;    var blood, currentPos;&#x000A;    heading = Point.direction(Point(0, 0), I.velocity);&#x000A;    currentPos = self.center();&#x000A;    if (lastPosition && (blood = I.blood)) {&#x000A;      I.blood -= 1;&#x000A;      bloodCanvas.drawLine({&#x000A;        color: BLOOD_COLOR,&#x000A;        start: lastPosition,&#x000A;        end: currentPos,&#x000A;        width: (blood / 20).clamp(1, 6)&#x000A;      });&#x000A;    }&#x000A;    return lastPosition = currentPos;&#x000A;  };&#x000A;  self.bind("drawDebug", function(canvas) {&#x000A;    var center, scaledVelocity, x, y;&#x000A;    center = self.center();&#x000A;    x = center.x;&#x000A;    y = center.y;&#x000A;    scaledVelocity = I.velocity.scale(10);&#x000A;    return canvas.drawLine({&#x000A;      color: "orange",&#x000A;      start: Point(x, y),&#x000A;      end: Point(x + scaledVelocity.x, y + scaledVelocity.y)&#x000A;    });&#x000A;  });&#x000A;  self.bind("step", function() {&#x000A;    drawBloodStreaks();&#x000A;    if (I.superMassive) return addParticleEffect(I.velocity.scale(-1));&#x000A;  });&#x000A;  self.bind("positionUpdated", function() {&#x000A;    var circle;&#x000A;    if (!I.active) return;&#x000A;    circle = self.circle();&#x000A;    if (DEBUG_DRAW) {&#x000A;      bloodCanvas.drawCircle({&#x000A;        circle: circle,&#x000A;        color: "rgba(0, 255, 0, 0.1)"&#x000A;      });&#x000A;    }&#x000A;    return engine.find("Goal").each(function(goal) {&#x000A;      if (goal.withinGoal(circle)) {&#x000A;        self.destroy();&#x000A;        goal.score();&#x000A;        return engine.delay(30, function() {&#x000A;          return engine.add({&#x000A;            "class": "Puck"&#x000A;          });&#x000A;        });&#x000A;      }&#x000A;    });&#x000A;  });&#x000A;  self.bind("update", function() {&#x000A;    return I.sprite = sprites[39];&#x000A;  });&#x000A;  self.bind("wallCollision", function() {&#x000A;    I.superMassive = false;&#x000A;    return I.friction = DEFAULT_FRICTION;&#x000A;  });&#x000A;  self.bind("superCharge", function() {&#x000A;    I.superMassive = true;&#x000A;    I.friction = 0;&#x000A;    return Sound.play("super_power");&#x000A;  });&#x000A;  self.mass = function() {&#x000A;    if (I.superMassive) {&#x000A;      return 9000;&#x000A;    } else {&#x000A;      return I.mass;&#x000A;    }&#x000A;  };&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var Rink;&#x000A;&#x000A;Rink = function(I) {&#x000A;  var backBoardsCanvas, blue, canvas, faceOffCircleRadius, faceOffSpotRadius, frontBoardsCanvas, red, rinkCornerRadius, self, spriteSize, x, y, _i, _len, _ref;&#x000A;  if (I == null) I = {};&#x000A;  Object.reverseMerge(I, {&#x000A;    team: "smiley",&#x000A;    spriteSize: 64&#x000A;  });&#x000A;  canvas = $("<canvas width=" + CANVAS_WIDTH + " height=" + CANVAS_HEIGHT + " />").appendTo("body").css({&#x000A;    position: "absolute",&#x000A;    top: 0,&#x000A;    left: 0,&#x000A;    zIndex: "-10"&#x000A;  }).pixieCanvas();&#x000A;  red = "red";&#x000A;  blue = "blue";&#x000A;  faceOffSpotRadius = 5;&#x000A;  faceOffCircleRadius = 38;&#x000A;  rinkCornerRadius = Rink.CORNER_RADIUS;&#x000A;  canvas.drawRoundRect({&#x000A;    color: "white",&#x000A;    x: WALL_LEFT,&#x000A;    y: WALL_TOP,&#x000A;    width: ARENA_WIDTH,&#x000A;    height: ARENA_HEIGHT,&#x000A;    radius: rinkCornerRadius&#x000A;  });&#x000A;  _ref = [ARENA_WIDTH / 3, ARENA_WIDTH * 2 / 3];&#x000A;  for (_i = 0, _len = _ref.length; _i < _len; _i++) {&#x000A;    x = _ref[_i];&#x000A;    x += WALL_LEFT;&#x000A;    canvas.drawLine({&#x000A;      color: blue,&#x000A;      start: Point(x, WALL_TOP),&#x000A;      end: Point(x, WALL_BOTTOM),&#x000A;      width: 4&#x000A;    });&#x000A;  }&#x000A;  x = WALL_LEFT + ARENA_WIDTH / 2;&#x000A;  canvas.drawLine({&#x000A;    color: red,&#x000A;    start: Point(x, WALL_TOP),&#x000A;    end: Point(x, WALL_BOTTOM),&#x000A;    width: 2&#x000A;  });&#x000A;  x = WALL_LEFT + ARENA_WIDTH / 2;&#x000A;  y = WALL_TOP + ARENA_HEIGHT / 2;&#x000A;  canvas.drawCircle({&#x000A;    x: x,&#x000A;    y: y,&#x000A;    radius: faceOffSpotRadius,&#x000A;    color: blue&#x000A;  });&#x000A;  canvas.drawCircle({&#x000A;    x: x,&#x000A;    y: y,&#x000A;    radius: faceOffCircleRadius,&#x000A;    stroke: {&#x000A;      color: blue,&#x000A;      width: 2&#x000A;    }&#x000A;  });&#x000A;  x = WALL_LEFT + ARENA_WIDTH / 10;&#x000A;  canvas.drawLine({&#x000A;    start: Point(x, WALL_TOP),&#x000A;    end: Point(x, WALL_BOTTOM),&#x000A;    width: 1,&#x000A;    color: red&#x000A;  });&#x000A;  canvas.drawRect({&#x000A;    x: x,&#x000A;    y: WALL_TOP + ARENA_HEIGHT / 2 - 16,&#x000A;    width: 16,&#x000A;    height: 32,&#x000A;    stroke: {&#x000A;      color: red&#x000A;    }&#x000A;  });&#x000A;  x = WALL_LEFT + ARENA_WIDTH * 9 / 10;&#x000A;  canvas.drawLine({&#x000A;    start: Point(x, WALL_TOP),&#x000A;    end: Point(x, WALL_BOTTOM),&#x000A;    width: 1,&#x000A;    color: red&#x000A;  });&#x000A;  canvas.drawRect({&#x000A;    x: x - 16,&#x000A;    y: WALL_TOP + ARENA_HEIGHT / 2 - 16,&#x000A;    width: 16,&#x000A;    height: 32,&#x000A;    stroke: {&#x000A;      color: red&#x000A;    }&#x000A;  });&#x000A;  [1, 3].each(function(verticalQuarter) {&#x000A;    y = WALL_TOP + verticalQuarter / 4 * ARENA_HEIGHT;&#x000A;    return [1 / 5, 1 / 3 + 1 / 40, 2 / 3 - 1 / 40, 4 / 5].each(function(faceOffX, i) {&#x000A;      x = WALL_LEFT + faceOffX * ARENA_WIDTH;&#x000A;      canvas.drawCircle({&#x000A;        x: x,&#x000A;        y: y,&#x000A;        radius: faceOffSpotRadius,&#x000A;        color: red&#x000A;      });&#x000A;      if (i === 0 || i === 3) {&#x000A;        return canvas.drawCircle({&#x000A;          x: x,&#x000A;          y: y,&#x000A;          radius: faceOffCircleRadius,&#x000A;          stroke: {&#x000A;            color: red,&#x000A;            width: 2&#x000A;          }&#x000A;        });&#x000A;      }&#x000A;    });&#x000A;  });&#x000A;  spriteSize = 64;&#x000A;  backBoardsCanvas = $("<canvas width=" + CANVAS_WIDTH + " height=" + CANVAS_HEIGHT + " />").appendTo("body").css({&#x000A;    position: "absolute",&#x000A;    top: 0,&#x000A;    left: 0,&#x000A;    zIndex: "-4"&#x000A;  }).pixieCanvas();&#x000A;  Sprite.loadByName("" + I.spriteSize + "/" + I.team + "_wall_n", function(sprite) {&#x000A;    return backBoardsCanvas.withTransform(Matrix.translation(WALL_LEFT + 128, WALL_TOP - 64), function() {&#x000A;      return sprite.fill(backBoardsCanvas, 0, 0, I.spriteSize * 12, I.spriteSize);&#x000A;    });&#x000A;  });&#x000A;  Sprite.loadByName("" + I.spriteSize + "/" + I.team + "_wall_nw", function(sprite) {&#x000A;    return backBoardsCanvas.withTransform(Matrix.translation(WALL_LEFT, WALL_TOP - 64), function() {&#x000A;      return sprite.draw(backBoardsCanvas, 0, 0);&#x000A;    });&#x000A;  });&#x000A;  Sprite.loadByName("" + I.spriteSize + "/" + I.team + "_wall_nw", function(sprite) {&#x000A;    return backBoardsCanvas.withTransform(Matrix.translation(WALL_RIGHT, WALL_TOP - 64), function() {&#x000A;      return backBoardsCanvas.withTransform(Matrix.scale(-1, 1), function() {&#x000A;        return sprite.draw(backBoardsCanvas, 0, 0);&#x000A;      });&#x000A;    });&#x000A;  });&#x000A;  frontBoardsCanvas = $("<canvas width=" + CANVAS_WIDTH + " height=" + CANVAS_HEIGHT + " />").appendTo("body").css({&#x000A;    position: "absolute",&#x000A;    top: 0,&#x000A;    left: 0,&#x000A;    zIndex: "1"&#x000A;  }).pixieCanvas();&#x000A;  Sprite.loadByName("" + I.spriteSize + "/" + I.team + "_wall_sw", function(sprite) {&#x000A;    return frontBoardsCanvas.withTransform(Matrix.translation(WALL_LEFT, WALL_BOTTOM - 112), function() {&#x000A;      return sprite.draw(frontBoardsCanvas, 0, 0);&#x000A;    });&#x000A;  });&#x000A;  Sprite.loadByName("" + I.spriteSize + "/" + I.team + "_wall_sw", function(sprite) {&#x000A;    return frontBoardsCanvas.withTransform(Matrix.translation(WALL_RIGHT, WALL_BOTTOM - 112), function() {&#x000A;      return frontBoardsCanvas.withTransform(Matrix.scale(-1, 1), function() {&#x000A;        return sprite.draw(frontBoardsCanvas, 0, 0);&#x000A;      });&#x000A;    });&#x000A;  });&#x000A;  Sprite.loadByName("" + I.spriteSize + "/" + I.team + "_wall_s", function(sprite) {&#x000A;    return frontBoardsCanvas.withTransform(Matrix.translation(WALL_LEFT + 128, WALL_BOTTOM - 48), function() {&#x000A;      return sprite.fill(frontBoardsCanvas, 0, 0, I.spriteSize * 12, I.spriteSize);&#x000A;    });&#x000A;  });&#x000A;  Sprite.loadByName("" + I.spriteSize + "/norm_wall_w", function(sprite) {&#x000A;    frontBoardsCanvas.withTransform(Matrix.translation(WALL_LEFT, WALL_TOP + 96), function(canvas) {&#x000A;      return sprite.fill(canvas, -I.spriteSize / 2, -I.spriteSize / 2, I.spriteSize, I.spriteSize * 6);&#x000A;    });&#x000A;    return frontBoardsCanvas.withTransform(Matrix.translation(WALL_RIGHT, WALL_TOP + 96), function(canvas) {&#x000A;      return canvas.withTransform(Matrix.scale(-1, 1), function() {&#x000A;        return sprite.fill(canvas, -I.spriteSize / 2, -I.spriteSize / 2, I.spriteSize, I.spriteSize * 6);&#x000A;      });&#x000A;    });&#x000A;  });&#x000A;  self = {&#x000A;    show: function() {&#x000A;      return [canvas, frontBoardsCanvas, backBoardsCanvas].each(function(c) {&#x000A;        return $(c.element()).show();&#x000A;      });&#x000A;    },&#x000A;    hide: function() {&#x000A;      return [canvas, frontBoardsCanvas, backBoardsCanvas].each(function(c) {&#x000A;        return $(c.element()).hide();&#x000A;      });&#x000A;    }&#x000A;  };&#x000A;  return self;&#x000A;};&#x000A;&#x000A;Rink.CORNER_RADIUS = 96;&#x000A;&#x000A;var Scoreboard;&#x000A;&#x000A;Scoreboard = function(I) {&#x000A;  var endGameChecks, nextPeriod, self;&#x000A;  $.reverseMerge(I, {&#x000A;    gameOver: false,&#x000A;    score: {&#x000A;      home: 0,&#x000A;      away: 0&#x000A;    },&#x000A;    period: 0,&#x000A;    periodTime: 1 * 60 * 30,&#x000A;    reverse: false,&#x000A;    sprite: Sprite.loadByName("scoreboard"),&#x000A;    time: 0,&#x000A;    x: rand(App.width).snap(32),&#x000A;    y: rand(WALL_TOP).snap(32),&#x000A;    zamboniInterval: 30 * 30,&#x000A;    zIndex: 10&#x000A;  });&#x000A;  endGameChecks = function() {&#x000A;    if (I.period >= 4) {&#x000A;      if (I.score.home > I.score.away) {&#x000A;        I.winner = "HOME";&#x000A;      } else if (I.score.away > I.score.home) {&#x000A;        I.winner = "AWAY";&#x000A;      }&#x000A;      if (I.winner) {&#x000A;        I.gameOver = true;&#x000A;        return I.time = 0;&#x000A;      } else if (I.period === 4) {&#x000A;        return engine.find("Goal").each(function(goal) {&#x000A;          return goal.suddenDeath(true);&#x000A;        });&#x000A;      }&#x000A;    }&#x000A;  };&#x000A;  nextPeriod = function() {&#x000A;    I.time = I.periodTime;&#x000A;    I.period += 1;&#x000A;    return endGameChecks();&#x000A;  };&#x000A;  nextPeriod();&#x000A;  self = GameObject(I).extend({&#x000A;    draw: function(canvas) {&#x000A;      var color, minutes, seconds, time;&#x000A;      I.sprite.draw(canvas, WALL_LEFT + (ARENA_WIDTH - I.sprite.width) / 2, 16);&#x000A;      time = Math.max(I.time, 0);&#x000A;      minutes = (time / 30 / 60).floor();&#x000A;      seconds = ((time / 30).floor() % 60).toString();&#x000A;      if (seconds.length === 1) seconds = "0" + seconds;&#x000A;      canvas.font("bold 24px consolas, 'Courier New', 'andale mono', 'lucida console', monospace");&#x000A;      canvas.drawText({&#x000A;        color: "red",&#x000A;        text: "" + minutes + ":" + seconds,&#x000A;        x: WALL_LEFT + ARENA_WIDTH / 2 - 22,&#x000A;        y: 46&#x000A;      });&#x000A;      canvas.drawText({&#x000A;        color: "red",&#x000A;        text: I.period,&#x000A;        x: WALL_LEFT + ARENA_WIDTH / 2 + 18,&#x000A;        y: 84&#x000A;      });&#x000A;      canvas.drawText({&#x000A;        color: "red",&#x000A;        text: I.score.away,&#x000A;        x: WALL_LEFT + ARENA_WIDTH / 2 - 72,&#x000A;        y: 60&#x000A;      });&#x000A;      canvas.drawText({&#x000A;        color: "red",&#x000A;        text: I.score.home,&#x000A;        x: WALL_LEFT + ARENA_WIDTH / 2 + 90,&#x000A;        y: 60&#x000A;      });&#x000A;      if (I.gameOver) {&#x000A;        canvas.centerText({&#x000A;          color: "#000",&#x000A;          text: "GAME OVER",&#x000A;          y: 384&#x000A;        });&#x000A;        if (I.winner === "HOME") {&#x000A;          color = "#F00";&#x000A;        } else {&#x000A;          color = "#00F";&#x000A;        }&#x000A;        return canvas.centerText({&#x000A;          color: color,&#x000A;          text: "" + I.winner + " WINS",&#x000A;          y: 416&#x000A;        });&#x000A;      } else if (I.period >= 4) {&#x000A;        return canvas.centerText({&#x000A;          color: "#0F0",&#x000A;          text: "SUDDEN DEATH",&#x000A;          y: 120&#x000A;        });&#x000A;      }&#x000A;    },&#x000A;    score: function(team) {&#x000A;      if (!I.gameOver) I.score[team] += 1;&#x000A;      return endGameChecks();&#x000A;    }&#x000A;  });&#x000A;  self.bind("update", function() {&#x000A;    if (I.time % I.zamboniInterval === 0) {&#x000A;      if (!(I.time === I.periodTime && I.period === 1)) {&#x000A;        I.reverse = !I.reverse;&#x000A;        engine.add({&#x000A;          "class": "Zamboni",&#x000A;          reverse: I.reverse,&#x000A;          team: ["smiley", "spike"].rand()&#x000A;        });&#x000A;      }&#x000A;    }&#x000A;    I.time -= 1;&#x000A;    if (I.gameOver) {&#x000A;      return MAX_PLAYERS.times(function(i) {&#x000A;        var controller;&#x000A;        controller = engine.controller(i);&#x000A;        if (controller.actionDown("START")) return self.trigger("restart");&#x000A;      });&#x000A;    } else {&#x000A;      if (I.time === 0) return nextPeriod();&#x000A;    }&#x000A;  });&#x000A;  self.attrReader("gameOver");&#x000A;  return self;&#x000A;};&#x000A;&#x000A;var Shockwave;&#x000A;&#x000A;Shockwave = function(I) {&#x000A;  var addParticleEffect, constructGradient, drawScorch, flameEndColor, flameMiddleColor, flameStartColor, particleColors, particleSizes, self, shadowColor, transparentColor;&#x000A;  I || (I = {});&#x000A;  $.reverseMerge(I, {&#x000A;    radius: 10,&#x000A;    maxRadius: 150,&#x000A;    offsetHeight: -12,&#x000A;    zIndex: 3&#x000A;  });&#x000A;  flameStartColor = "rgba(64, 8, 4, 0.5)";&#x000A;  flameMiddleColor = "rgba(192, 128, 64, 0.9)";&#x000A;  flameEndColor = "rgba(192, 32, 16, 1)";&#x000A;  transparentColor = "rgba(0, 0, 0, 0)";&#x000A;  shadowColor = "rgba(0, 0, 0, 0.5)";&#x000A;  drawScorch = function() {&#x000A;    var scorch;&#x000A;    scorch = Shockwave.scorchSprite;&#x000A;    return bloodCanvas.withTransform(Matrix.translation(I.x - scorch.width / 2, I.y - scorch.height / 2), function() {&#x000A;      return scorch.draw(bloodCanvas, 0, 0);&#x000A;    });&#x000A;  };&#x000A;  particleSizes = [8, 4, 8, 16, 24, 12];&#x000A;  particleColors = ["rgba(255, 0, 128, 0.75)", "#333"];&#x000A;  addParticleEffect = function() {&#x000A;    var v;&#x000A;    v = I.velocity.norm(5);&#x000A;    return engine.add({&#x000A;      "class": "Emitter",&#x000A;      duration: 21,&#x000A;      sprite: Sprite.EMPTY,&#x000A;      velocity: I.velocity,&#x000A;      particleCount: 9,&#x000A;      batchSize: 5,&#x000A;      x: I.x,&#x000A;      y: I.y,&#x000A;      zIndex: 3,&#x000A;      generator: {&#x000A;        color: function(n) {&#x000A;          return particleColors.wrap(n);&#x000A;        },&#x000A;        duration: 20,&#x000A;        height: function(n) {&#x000A;          return particleSizes.wrap(n);&#x000A;        },&#x000A;        maxSpeed: 50,&#x000A;        velocity: function(n) {&#x000A;          return Point.fromAngle(Random.angle()).scale(5).add(v);&#x000A;        },&#x000A;        width: function(n) {&#x000A;          return particleSizes.wrap(n);&#x000A;        }&#x000A;      }&#x000A;    });&#x000A;  };&#x000A;  constructGradient = function(context, min, max, shadow) {&#x000A;    var radialGradient, y;&#x000A;    if (shadow == null) shadow = false;&#x000A;    if (shadow) {&#x000A;      y = I.y;&#x000A;    } else {&#x000A;      y = I.y + I.offsetHeight;&#x000A;    }&#x000A;    radialGradient = context.createRadialGradient(I.x, y, 0, I.x, y, max);&#x000A;    if (min > 0) {&#x000A;      radialGradient.addColorStop(0, transparentColor);&#x000A;      radialGradient.addColorStop((min - 1) / max, transparentColor);&#x000A;    }&#x000A;    if (shadow) {&#x000A;      radialGradient.addColorStop(min / max, shadowColor);&#x000A;      radialGradient.addColorStop(1, shadowColor);&#x000A;    } else {&#x000A;      radialGradient.addColorStop(min / max, flameStartColor);&#x000A;      radialGradient.addColorStop((min + max) / (2 * max), flameMiddleColor);&#x000A;      radialGradient.addColorStop(1, flameEndColor);&#x000A;    }&#x000A;    return radialGradient;&#x000A;  };&#x000A;  I.create = function() {&#x000A;    Sound.play("explosion");&#x000A;    addParticleEffect();&#x000A;    return drawScorch();&#x000A;  };&#x000A;  self = GameObject(I).extend({&#x000A;    draw: function(canvas) {&#x000A;      var g, max, min;&#x000A;      min = Math.max(I.radius - 20, 0);&#x000A;      max = I.radius;&#x000A;      g = constructGradient(canvas.context(), min, max, true);&#x000A;      canvas.drawCircle({&#x000A;        position: I,&#x000A;        radius: max,&#x000A;        color: g&#x000A;      });&#x000A;      g = constructGradient(canvas.context(), min, max);&#x000A;      return canvas.drawCircle({&#x000A;        x: I.x,&#x000A;        y: I.y + I.offsetHeight,&#x000A;        radius: max,&#x000A;        color: g&#x000A;      });&#x000A;    }&#x000A;  });&#x000A;  self.bind("step", function() {&#x000A;    var maxCircle, minCircle;&#x000A;    maxCircle = I;&#x000A;    minCircle = {&#x000A;      x: I.x,&#x000A;      y: I.y,&#x000A;      radius: Math.max(I.radius - 20, 0)&#x000A;    };&#x000A;    engine.find("Player, Zamboni, Puck").each(function(object) {&#x000A;      var objectCircle, shockwaveForce;&#x000A;      objectCircle = object.circle();&#x000A;      if (Collision.circular(objectCircle, maxCircle) && !Collision.circular(objectCircle, minCircle)) {&#x000A;        shockwaveForce = object.center().subtract(I).norm(20);&#x000A;        object.wipeout(shockwaveForce);&#x000A;        return object.I.velocity = object.I.velocity.add(shockwaveForce);&#x000A;      }&#x000A;    });&#x000A;    I.radius += 10;&#x000A;    if (I.radius > I.maxRadius) return self.destroy();&#x000A;  });&#x000A;  return self;&#x000A;};&#x000A;&#x000A;Shockwave.scorchSprite = Sprite.loadByName("scorch");&#x000A;&#x000A;var SideBoards;&#x000A;&#x000A;SideBoards = function(I) {&#x000A;  var self;&#x000A;  if (I == null) I = {};&#x000A;  Object.reverseMerge(I, {&#x000A;    spriteName: "norm_wall_w",&#x000A;    width: 64,&#x000A;    height: 64,&#x000A;    scale: 1 / 8,&#x000A;    x: 0,&#x000A;    y: WALL_TOP + 96,&#x000A;    repetitions: 5,&#x000A;    flip: 1&#x000A;  });&#x000A;  self = GameObject(I).extend({&#x000A;    draw: function(canvas) {&#x000A;      return canvas.withTransform(Matrix.translation(I.x, I.y), function() {&#x000A;        return canvas.withTransform(Matrix.scale(I.flip * I.scale, I.scale), function() {&#x000A;          return I.sprite.fill(canvas, -256, -256, 512, 512 * I.repetitions);&#x000A;        });&#x000A;      });&#x000A;    }&#x000A;  });&#x000A;  return self;&#x000A;};</code></pre>
        </section>
      </div>
      <hr />
      <a name='#strokeColor'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#strokeColor(color)</h1>
      <div class='description'>
        <section class='summary'><p>A getter / setter method to set the canvas strokeColor.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          <p><code><pre></p>&#x000A;&#x000A;<h1>Set the stroke color</h1>&#x000A;&#x000A;<p>canvas.strokeColor('#FF0000')</p>&#x000A;&#x000A;<h1>Passing no arguments returns the strokeColor</h1>&#x000A;&#x000A;<p>canvas.strokeColor()</p>&#x000A;&#x000A;<h1>=> '#FF0000'</h1>&#x000A;&#x000A;<h1>You can also pass a Color object</h1>&#x000A;&#x000A;<p>canvas.strokeColor(Color('sky blue'))<br /></pre></code>      </p>
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>color</span>
               -
              <span class='param_description'>color to make the canvas strokeColor</span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>strokeColor: function(color) {&#x000A;        if (color) {&#x000A;          if (color.channels) {&#x000A;            context.strokeStyle = color.toString();&#x000A;          } else {&#x000A;            context.strokeStyle = color;&#x000A;          }&#x000A;          return this;&#x000A;        } else {&#x000A;          return context.strokeStyle;&#x000A;        }&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
      <a name='#withTransform'></a>
      <!-- TODO make sure method_data isn't nil -->
      <h1>PixieCanvas#withTransform(matrix, block)</h1>
      <div class='description'>
        <section class='summary'><p>Passes this canvas to the block with the given matrix transformation<br />applied. All drawing methods called within the block will draw<br />into the canvas with the transformation applied. The transformation<br />is removed at the end of the block, even if the block throws an error.</p></section>
        <section class='usage'>
          <h3>Usage</h3>
          
        </section>
        <section class='parameters'>
          <h3>Parameters</h3>
          <ul>
            <li>
              <span class='param_name'>matrix</span>
               -
              <span class='param_description'></span>
            </li>
            <li>
              <span class='param_name'>block</span>
               -
              <span class='param_description'></span>
            </li>
          </ul>
        </section>
        <section class='returns'>
          <h3>Returns</h3>
          <p>
            Type:
            <a href='PixieCanvas.html'>PixieCanvas</a>
          </p>
          <p class='return_description'>this</p>
        </section>
        <section class='source'>
          <h3>Source</h3>
          <a class='toggle_source'>Toggle</a>
          <pre><code>withTransform: function(matrix, block) {&#x000A;        context.save();&#x000A;        context.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);&#x000A;        try {&#x000A;          block(this);&#x000A;        } finally {&#x000A;          context.restore();&#x000A;        }&#x000A;        return this;&#x000A;      },</code></pre>
        </section>
      </div>
      <hr />
    </div>
  </body>
</html>
<script type='text/javascript'>
  //<![CDATA[
    $(function() {
      $(".documentation").on("click", ".toggle_source", function(e) {
        e.preventDefault();
        return $(this).next().toggle();
      });
      return $("code.run").each(function() {
        var canvas, codeElement, compiledJs, source;
        codeElement = $(this);
        source = codeElement.text();
        compiledJs = CoffeeScript.compile(source, {
          bare: true
        });
        canvas = $("<canvas width=200 height=150/>").pixieCanvas();
        codeElement.after(canvas);
        return eval(compiledJs);
      });
    });
  //]]>
</script>
